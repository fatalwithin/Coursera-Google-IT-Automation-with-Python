# Week 1
## Course Intro

In your IT career, you'll come across many different flavors of technical problems. Sometimes, you might need to figure out why a program isn't doing what it's supposed to.  
Maybe it's crashing unexpectedly or getting stuck when it should be processing information.  
Other times, you'll need to find a way to make your script run **faster** or use **less memory** or transmit less data over the network.  
Or you might need to work out why the overall system isn't running as expected and how to fix it even if you didn't write the code that's causing the problems. 

Throughout this course, we'll look at a bunch of different strategies and approaches for tackling problems like those. We'll learn some general ideas that can help us solve almost any technical problem. Then see how these ideas apply to different real world scenarios.  
We picked examples that include **general system issues**, issues with **software** that someone else wrote and issues with **programs** that we wrote. We'll talk about problems that can affect **any operating system**. We'll also look at problems specific to certain platforms. 

For scripting problems, will focus on Python programs but we'll also check out common issues that can happen with other languages too. My name's Amanda Ballas and I'm a Security Systems Administrator in the detection and response operations team at Google.  
In my day to day role, I manage Linux servers with a special focus on security. It's my job to take care of the systems that monitor the internal network from malicious signals, to make sure we can catch bad actors quickly. I'm one of my teams tech leads. When I took on this role, I also took over ownership of systems that I didn't write myself.  
That meant I took ownership of thousands of lines of code which I had to familiarize myself with so that I could keep adding new features and maintaining the existing code.  
This can be extra challenging when trying to figure out why things aren't working as expected or worse when dealing with an outage. Before we jump in, I'd love to take a quick moment to share why I'm so excited to be here with you taking part in this program.  

As a woman in tech too often, when I'm at a conference, training, or really just any tech event, my voice isn't heard. Sometimes when people ask what my team does, they don't look at me.  
They don't expect me to reply and they don't take me seriously when I speak. So I'm here to show that I have a voice and I know what I'm talking about. It shouldn't matter if you're a man, a woman, or part of a gender minority, it's your technical expertise that matters.  
So here I am, excited to share my technical expertise with you. As you know, this program has been designed and developed exclusively by Google and each course takes place at a different campus location to bring you extra Google goodness. This is one of our Google work spaces where we can hunker down together when we're troubleshooting a problem. 

There's a lot to learn about troubleshooting and debugging. In this course, will give you the tools to solve real world problems that you might come across in your IT role. The scenarios that we'll talk about are based on actual IT problems. We'll invite you to share with your fellow learners, other examples that you've solved yourself. In this course, we'll use Qwiklabs which is an environme nt that allows you to test your code on a virtual machine running Linux. This will let you experience real world Linux scenarios where you'll need to understand and solve some example problems using the techniques that you'll learn in this course.  
Please remember, some of these topics and videos are complex and they may not 100 percent sink in the first time around. That's totally natural. Take your time and rewatch the videos a few times if you need to. You'll get the hang of it all. Also, remember that you can use the discussion forums to connect with your fellow learners and ask questions anytime you need. All right. Are you ready to expand our troubleshooting and debugging abilities? Great. Let's get started.

## Introduction to Debugging

### Intro to Module 1: Troubleshooting Concepts

Whether it's an application crashing, a hardware issue, or network outage, as IT specialists, we tend to run into problems that need solving pretty regularly. When facing these issues, we need to make sure that people affected by the problem can get back to doing their jobs as fast as possible.  
We also have to plan for how to prevent against the same problems from happening again in the future. In this module, we'll learn some essential debugging techniques. 

We'll start with the basic process that we can use for tackling any technical problem. Then we'll look at different ways that we can approach understanding what's going on and finding the root cause of an issue, including using a process called **binary search** to troubleshoot problems. Along the way, we'll talk about a bunch of examples of real-world problems and how to apply the techniques to solve them.  
The techniques we'll look at are reusable and we'll let you solve almost any technical problem that you might face in the future.  
We'll keep applying them throughout the course as we explore different issues that can affect us or the users we're supporting in different ways. As with any other skills that you've learned throughout this program, the best way to get good at something is practice. 

So at the end of the module, you'll have the opportunity to apply these techniques and try solving a technical issue yourself on a virtual machine running Linux. Finding the solution to a problem can sometimes take a really long time. While I don't know if anyone loves troubleshooting, I definitely enjoy solving problems. Dealing with software is like trying to solve one giant puzzle. It can sometimes be frustrating when we can't find the right pieces. But it's super exciting when everything finally fits together. If everything I did worked right away, then it wouldn't be fun anymore. I love the challenge. Let's get you started.

### What is debugging?

Throughout this course, we'll be talking about debugging and troubleshooting. So what's the difference between them?  
We say that **troubleshooting is the process of identifying, analyzing, and solving problems**. We can use the term troubleshooting to refer to solving **any** kind of problem. In this course, we'll focus on troubleshooting IT-related problems. 

They could be problems caused by hardware, the operating system, or applications running on the computer. They could also be caused by the environment and configuration of the software. The services the application is interacting with, or a wide range of other possible IT causes. 

On the flip side, **debugging is the process of identifying, analyzing, and removing bugs in a system**. We sometimes use troubleshooting and debugging **interchangeably**. But generally, we say troubleshooting when we're fixing problems **in the system** running the application, and debugging when we're fixing the bugs in the **actual code** of the application.  
There are lots of tools that we can use to get more information about the system and what the programs in our system are doing. Tools like **tcpdump** and **Wireshark** can show us ongoing network connections, and help us analyze the traffic going over our cables.  
Tools like **ps**, **top**, or **free** can show us the number and types of resources used in the system. We can use a tool like **strace** to look at the system calls made by a program, or **ltrace** to look at the library calls made by the software.  

Don't worry about memorizing them, we'll talk about each in detail in our real-world examples. When debugging the code of a program, we can combine these tools with specific debugging tools developed for the programming language used to write the application.  
**Debuggers** let us follow the code line by line, **inspect changes in variable assignments, interrupt the program when a specific condition is met**, and more. On top of that, if we can modify the code, we can change it so that it provides more logging information. This can help us understand what's going on behind the scenes.  
Both troubleshooting and debugging are a bit of an art. In those fortunate cases when you've seen the problem before, you might immediately know what the solution is. But usually, figuring out the problem and its solution require some creativity. We need to come up with new ideas of what could be failing, and ways to check for that. And once we know what's failing, we need to imagine how to solve it. To take it a step further, once we've solved a problem, we can start thinking about how to prevent it from happening again.

I remember a tricky debugging session that I had on my last team. We recently added integration tests to one of our pipelines to make sure the service worked correctly before automatically building and deploying a new version. The test ran fine for about a month, and then it started to fail. Since this was an integration test that would prevent a broken version from getting released, I was really surprised to discover that the broken code was actually already live in the production server. I looked at tons of logs and spent a long time following what the code did.  
Finally, I noticed that the problem was that the tests were running against the production instance, instead of the test instance as we originally intended. In other words, the test would pass as long as the production instance was working fine. And would break when the production instance was broken, not what we wanted at all. 

To fix the problem, I had to figure out why the test code didn't connect to the test instance that we were creating inside the integration test. After a lot more investigation, I discovered that the test instance was failing to start because the execution path was incorrect. To fix this, I ended up modifying a library provided by a different team to pass the right parameter. And voila, the test started running against the code in the test instance, not the production instance anymore.  
When troubleshooting or debugging, we come across surprising situations. Things aren't working as expected, and we need to understand why, and figure out how to solve it. As we called out, in this course, we'll look into a bunch of different techniques to understand and solve technical problems. While we'll sometimes focus on system side and sometimes on the coding side, most of the techniques that we'll cover can help us solve any technical problem. Up next, we'll talk about the steps we need to take to solve any kind of technical problem.

### Problem Solving Steps

There's a wide range of different technical problems that you might face as an IT specialist or systems administrator. But fortunately, there's a **set of steps** that you can usually take to solve **almost any technical problem**. 

**The first step is getting information**. This means gathering as much information as we need about the current state of things, what the issue is, when it happens, and what the consequences are, for example.  
To get this information, we can use **any existing documentation** that might help. This can be internal documentation, manual pages, or even questions asked on the Internet. One super important resource to solve a problem is the **reproduction case, which is a clear description of how and when the problem appears**.  

**The second step is finding the root cause of the problem**. This is usually the most difficult step. Throughout this course, we'll discuss a lot of possibilities on how to get there. But the key here is to get to the **bottom** of what's going on, what **triggered** the problem, and how we can change that. 

**The final step is performing the necessary remediation**. Depending on the problem, this might include an immediate remediation to get the system **back to health**, and then a medium or long-term remediation to avoid the problem in the future.

 While these are three basic steps of problem-solving, they don't always happen sequentially. It's pretty common that while trying to find the root cause, we discover that we need even more info about the current state.  
So we gather more information until we find the answer we're looking for, or we could understand the problem just enough to create a **workaround** that lets our users get back to work quickly, but we'd still need more time to get to the root cause and prevent the problem from happening again. Preventing the problem from occurring can sometimes feel like a hassle, but it can actually save us and our users a lot of valuable time. This way we avoid having to solve the same problem over and over again. 

Throughout the whole process, it's important that **we document what we do**. We should note down the info that we get, the different things we tested to try, and figure out the root cause. Finally, the steps we took to fix the issue.  
This documentation might prove invaluable next time a similar issue pops up. 

Imagine a user asks you for your help because their computer is unexpectedly shutting down. Computers shouldn't shut down on their own, but the problem could be a hardware issue, a software issue, or even a configuration issue. 
So the first thing to do is to get more information. You'll want to know things like when it happened, what the user was doing when it happened, and how regularly it's happening.  
You'll also want to look at the computer logs to check if there are any interesting errors. If any aren't totally clear, you can look them up on the Internet to see what they mean. In our example, safe on a line in the logs that says the temperature threshold was exceeded and so the computer shutdown.  
That's useful information, you know why the computer shut down but you don't know why it overheated, so you'll need to keep investigating. After not finding anything else interesting in the logs, you decide to check if it's a hardware issue.  
When you open up the computer, you find that the fan that's supposed to cool down the CPU is full of dirt, and so it isn't spinning properly. That's the root cause of the problem.  

Now, the short-term remediation is to clean up the fan so that it can spin again and the computer doesn't overheat. But what's the long-term remediation? In this case, it would be **deploying monitoring** on the computers to make sure you get notified early when they're overheating. Long-term remediation would also include checking if you can reduce the amount of dust in the air so that there's less chance of this happening again. Up next, we'll put these steps to the test by applying them to solve a practical example.

### Silently Crashing Application

Say a user contacts us to let us know that a certain application fails to open. As we called out earlier the first thing to do is to get more information about the conditions that caused the failure. What the error is that the user is getting and then check if we experience the same failure.  
By asking for these details, we discover that a **new version of the software** was recently released. And when we upgrade to this new version, we can reproduce the problem on our own computer like this.

We see that when we try to run the program it prints no error at all. It just exits immediately. We need to figure out what's going on. Even if there's no error message.  
There are a bunch of tools that can help us better understand what's going on with the system and with our applications. With the help of these tools, we can extend our knowledge of a particular problem view the actions of the program from a different point of view and get the info we need. Among these tools **strace** lets us look more deeply at what the program is doing. It will trace a system calls made by the program and tell us what the result of each of these calls was. So to figure out what's up with our program that's failing to open will strace the failing application.

Whoa, that's a lot of output the A strois command shows us all the system calls are program made. **System calls** are the calls that the programs running on our computer **make to the running kernel**. There are loads of different system calls and depending on what we're trying to debug. We might be interested in some more than others.  
If you want to understand what these system calls are. You can read more about each of them in the corresponding manual pages. But before we jump into that, let's make this output more manageable. We could pipe the output to the less command which we could use to scroll through a lot of texts or we could use the **-o flag of the astrois command to store the output into a file** and then browse the contents of that file. The -o flag, lets us refer back to the file later if we need to so, let's go with that one.

Okay, now we can read the generated file using whichever program we prefer. Let's open it with **less** will go to the end of the file pressing Shift+G then scroll up to see if we find anything suspicious.  
All right close to the end of the log we can see that the application tries to open a directory called .config purple box, which doesn't exist. Let's look at this line in a bit more detail. The name of the system call is open at. One of the calls used to open files or directories. The content of the call shows the parameters passed including the path that's being opened and a bunch of flags. In particular the O directory flag tells us that the program is trying to open this path as a directory. The number after the equal sign shows us the return code of the syscall. In this case it's negative one. So t**he program is trying to open this directory and it turns out it doesn't exist**.

Since this is happening shortly before the program finishes it's a likely candidate for the root cause of the issue. Let's create the directory and try to start the program again. Purple box, success this time the program works just fine. Let's recap what we did.  
**First** we got some **information** from a user telling us there was a change in the new version which was causing a problem. To investigate this we reproduce the problem on our own computer.  
Then we got more information on what was going on by using the **strace** tool which lets us see the system calls made by a program. We found a suspicious error. That's that a directory didn't exist.  
We created the directory to check out what would happen when it did exist and the program work correctly. So we've **identified the root cause** of the problem which is the missing directory.  

Now, we can go ahead and remediate the issue. The immediate remediation is to tell the user to create the directory so that they can get back to work quickly. The long-term remediation is to contact the developers of the software to let them know that the program will fail to start if the directory is missing. This gives them a heads up about the problem so they can fix it in the next version. And what about the documentation we should note that this version of the software won't start if that directory doesn't exist. That will help others facing the same issue to quickly find out the solution.  

In this example, we were able to use strace and quickly identify what the problem was but it won't always be this easy. Throughout this course, we'll keep looking at more tools and more ideas to help us work through what's going on when it's not immediately obvious. Coming up we've got the first practice quiz of the course. These quizzes will help make sure that all the concepts that we've covered thus far make sense. Remember you can always review the content if it wasn't clear. I'll meet you in the next video.

## Understanding the Problem

### "It Doesn't Work"

As we called out, the first step to solving a problem is getting **enough information** so that we can understand the current state of things. To do this we'll need to know what the actual issue we're solving is.  
This starts when we first come across the issue, which can be through report by a ticketing system or by encountering the problem ourselves. When working with users, it's pretty common to receive reports of failures that just boil down to, "**It doesn't work**." 

These reports usually don't include a lot of useful information but it's still important that the problem gets reported and solved. Which information is useful or not might **depend on the problem**. But there are some common questions that we can ask a user that simply report something doesn't work. 

What were you trying to do?  
What steps did you follow?  
What was the expected result?  
What was the actual result? 

If the ticketing system your company uses allows this, it's a good idea to include these questions in the form that users have to fill out when reporting an issue. This way we save time and can start asking more specific questions right away. Otherwise, these are almost always going to be the first questions you ask. Another thing to keep in mind is that when debugging a problem, **we want to consider the simplest explanations first** and avoid jumping into complex or time-consuming solutions unless we really have to. 

That's why **when a device doesn't turn on, we first check if it's correctly plugged in** and that there's electricity coming from the plug before taking it apart or replacing it with a new device. Say you got a call from a user that tells you the internal website used by the sales team to track customer interactions doesn't work. The user is super stressed because they need to access the information on the website for a meeting happening in a few minutes. So you tell them that you'll look into the problem right away, but then you need more information. 
What were they trying to do? The user tells you that they're trying to access the website.  
What steps did they follow? They tell you that they opened the website URL and entered their credentials.  
What was the expected result? They expected to see the sales system's landing page.  
What did they get instead? The web page just keeps loading. It stays blank forever. 

Okay. So now you've gone from, "it doesn't work," to, "when I tried to log in, the page keeps loading and never shows the landing page." That's great. Now that you have a basic idea of what the problem is, it's time to start figuring out the root cause. For that, you'll apply a process of elimination, starting with the simplest explanations first and testing those until you can isolate the root cause. For example, you check if you can **reproduce the issue on your own computer**. 

So you navigate to the website, enter your credentials, and sure enough, the page just keeps loading, never showing the landing page. This is enough information that you can tell the user that you'll work on it and investigate on your own. There's no need to keep them on the line. By reproducing the problem on your computer, you've taken a simple and quick action that rules out the user or the user's computer as the cause of the problem.  
This cuts the troubleshooting process in half since you now know there's a problem with the service and you can focus on solving that. Before jumping into the server that's hosting the application, you run a **few quick checks** to verify if the problem is isolated to that specific website or not.  
You check **if your Internet access is working successfully** by accessing an external website which loads just fine.  
Then you check if **other internal websites**, like the inventory website or ticketing system are working okay. 

Doing this, you discover that while the ticketing system loads with no issues, t**he inventory website never finishes loading**. It turns out **both websites are hosted on the same server**. Again, it's important to highlight that doing these quick checks to verify that the Internet works correctly and which sites are affected by the problem, helps you isolate the root cause. 

By looking at possible simple explanations first, you avoid losing time chasing the wrong problem. At this point, you know that website's running on a specific server or failing to load while the rest of the systems and the Internet are working correctly. Next up, you need to check what's going on on that server. The server running the websites is a Linux machine, so you'll connect to it using SSH. You run the top command which shows the state of the computer and processes using the most CPU and see that the **computer is super overloaded**.  
The load average in the first line says 40. The load average on Linux shows how much time a processor is busy in a given minute, with one meaning it was busy for the whole minute. So normally this number shouldn't be above the amount of processors in the computer. **A number higher than the amount of processors means the computer is overloaded**. You know this computer has four cores, so 40 is a really high number. 

You also see that most of the CPU time is spent in **waiting**. This means that **processes are stuck waiting for the operating system to return from system calls**.  
This usually happens when processes **get stuck gathering data from the hard drive or the network**.  
By looking at the list of processes, you realize that the **backup system is currently running** on the server, and it seems to be using a lot of processing time. Backing up the data on the system is super important. But currently, the whole system is unusable. 

So you decide to stop the backup system by calling kill-stop. This will suspend the execution of the program until you let it continue or decide to terminate it. After doing this, you're on top once again and you see that the load is going down, and so processes are no longer stuck waiting for I/O. Then you try logging into the website, and this time the landing page loads. Success. 

You let the user know that they can use the website once again. At this point, you've applied the immediate remediation. We'll talk about long-term remediation in a later video. Before moving on to the next topic, imagine that the following week another user calls you and tells you the sales website doesn't work. Remembering the previous incident, you tell them you'll fix it right away. You SSH onto the server and try to find the backup process to stop it, but it's not running. Oops. **You forgot to ask the user what they meant when they said it didn't work**. 

When you call back to ask them they tell you that they're trying to generate a monthly sales report and they get an error saying the product category column doesn't exist. Totally **different problem, totally different actions to take**. So remember to always have a clear picture of what the problem is before you start solving it. Up next, we'll talk about what are reproduction cases and how to come up with it.

### Creating a Reproduction Case

When we're dealing with an issue that's tricky to debug, we want to have a clear reproduction case for the problem. A reproduction case is a way to verify if the problem is present or not. We want to make the **reproduction case as simple as possible**. That way, we can clearly understand when it happens, and it makes it really easy to check if the problem is fixed or not, when we try to solve it. 

Sometimes, the reproduction case is pretty obvious. In our example where the program fail to start because of a missing directory, the reproduction case was to open the program without that directory on the computer.  
On our overloaded server example, the reproduction case for the failure was to try to login to the website and see the loading page. But sometimes the reproduction case might be much more complex to discover. Imagine you're trying to help a user with an application that won't start. This time when you run the same version of the application on your computer, the application starts just fine. 
So you suspect that the problem has to do with something in the user's environment or configuration. 

There could be a bunch of reasons why this could happen. It could be **problems with the network routing**, **old config files** interfering with a new version of the program, a **permissions problem** blocking the user from accessing some required resource, or even some **faulty piece of hardware** acting out.  
So how can you figure out what's causing the problem. 

**The first step is to read the logs** available to you. Which logs to read, will depend on the operating system and the application that you're trying to debug.  
On **Linux**, you'd read system logs like /var/log/syslog and user-specific logs like the.**xsession-errors** file located in the user's home directory.  
On **MacOs**, on top of the system logs, you'd go through the **logs stored in the library logs** directory.  
On **Windows**, you'd use the **Event Viewer** tool to go through the event logs.  
No matter the operating system, remember to look at the logs when something isn't behaving as it should. 

Lots of times, you'll find an error message that will help you understand what's going on like, unable to reach server, invalid file format, or permission denied. But what if you're unlucky, and there's no error message, or the error message is super unhelpful like internal system error. 

**The next step is to try to isolate the conditions that trigger the issue**.  
Do other users in the same office also experienced the problem?  
Does the same thing happen if the same user logs into a different computer?  
Does the problem happen if the applications config directory is moved away? 

Let's say that it's the config directories file. You ask the user to move it away without deleting it, and now the application starts correctly. So you ask the user to send you the contents of that directory. You copy them onto your computer, and the program fails to start.  
Bingo, you got your reproduction case. It's starting the program with that config in place. Having a clear reproduction case, let's do **investigate the issue**, and quickly see what changes it. 

For example, does the problem go away if you revert the application to the previous version?  
Are there any differences in the strace log, or the ltrace logs when running the application with the bug config and without it?  
On top of that, having a clear reproduction case, lets you share with others when asking for help. As long as you aren't sharing any confidential information of course, you could use it to **report a bug to the applications developers**, to ask for help from a colleague, or even to ask for help from an Internet forum about the application if it's publicly available. 

So when trying to create a reproduction case, we want to **find the actions that reproduce the issue**, and we want these to be **as simple as possible**. The smaller the change in the environment and the shorter the list of steps to follow, the better. To get there, we might need to dig deeper into the problem until we have a small enough set of instructions. Once you have a reproduction case, you're ready to move on to the next step, finding the root cause. We'll talk about that in our next video.

### Finding the Root Cause

When you first come across these concepts, it might seem that once you have a reproduction case, you already know the root cause of the problem. But more often than not, it's not true. 

In our overloaded server example, if the problem is with the hardware, we wouldn't be able to replicate it with a test server. In that case, we would need to either **wait until the services aren't being used** or bring up a secondary server, **migrate the services** there, and only then look at what's wrong with the computer.  
On the flip side, if the problem is related to some configuration of either the web services or the backup service, we'd still see it in the test server. 

So **we'd always start by setting up a test instance** of the service and checking if the problem replicates there before touching the production instance. So say we have a test server running the same websites. When we start the backup, we see that the website stop responding. This is great because we have re-production case, and we can debug it properly. 

How do we find the root cause?  
One possible culprit could be too much disk input and output. To get more info on this, we could use **iotop**, which is a tool similar to top that lets us see which processes are using the most input and output. Other related tools are **iostat** and **vmstat**, these tools **show statistics on the input/output operations and the virtual memory operations**. 

If the issue is that the process generates too much input or output, we could use a command like **ionice** to make our backup system reduce its priority to access the disk and let the web services use it too. What if the input and output is not the issue? Another option would be that the service is **using too much network** because it's transmitting the data to be backed up to a central server and that transmission blocks everything else.  

We can check this using **iftop**, yet another tool similar to top that shows the current traffic on the network interfaces. If the backup is eating all the network bandwidth, we could look at the documentation for the backup software and check if it already includes an option to **limit the bandwidth**.  
The **rsync** command, which is often used for backing up data, includes a **-bwlimit**, just for this purpose. If that option isn't available, we can use a program like **Trickle** to limit the bandwidth being used. But what if the network isn't the issue either? Remember, we need to put our debugging creativity to work, and come up with other possible reasons for why it's failing. 

Another option could be that the **compression algorithms selected is too aggressive**, and compressing the backups is using all of the server's processing power. We could solve this by reducing the compression level or using the **nice** command to reduce the priority of the process and accessing the CPU. If that's still not the case, we need to keep looking, **check the logs** to see if we find anything that we missed before. Maybe look online for other people dealing with similar problems related to interactions of the backing up software with the web surfing software, and keep doing this until we come up with something that could be causing our problem. 

I know this sounds like a lot of work, but it's usually not that bad. In general, by using the tools available to us, we can find enough info to land on the right hypothesis after only a few tries and with experience, we'll get better at picking up the most likely hypothesis the first time around. Up next, we'll talk about a tricky type of technical problem that we all have to face, intermittent issues.

### Dealing with Intermittent Issues

Have you ever tried to solve a problem that happened only **occasionally**? Maybe you've dealt with programs that **randomly crash**, laptops that sometimes **fail to suspend**, web services that unexpectedly **stop replying**, or file contents that get corrupted. But only in some cases, bugs that come and go are hard to reproduce, and are extremely annoying to debug. 

If you work in IT, you've probably had your own dose of frustration while dealing with intermittent and issues. So what can you do if you're trying to debug an issue like that?  
The **first step is to get more involved** in what's going on, so that you understand **when the issue happens and when it doesn't**. If you're dealing with a bug and a piece of code that you maintain, you can usually **modify the program to log more information** related to the problem.  
Since you don't know exactly when the bug will trigger, you need to be thorough with the information that you log. 

For example, I recently had an issue with the service IAM. It was crashing sporadically, and I was at a loss trying to find out why. Looking at the error message, I knew it had something to do with **strings that use special characters**, but I had no idea where the bug was exactly.  
So I added more logging information to the service, around the inputs and the function calls that I suspect could be involved. The next time the program crashed, I was able to identify the part of the code where I was missing the proper handling for the **encoding**, and fixed the problem. 

If you can't modify the code of the program to get more information, check if there's a logging configuration that you can change. Many applications and services already include a **debugging mode** that generates a lot more output then the default mode. By **enabling the debug information in advance**, you can get a better picture of what's going on the next time the problem happens.  
If that's not possible, you'll need to resort to monitoring the environment when the issue triggers. Depending on what the problem is, you might want to look at different sources of information, like the **load** on the computer, the processes running at the same time, the **usage** of the network, and so on. For bugs that occur at random times, we need to repair our system to give us as much information as possible when the bug happens.  
This might require several iterations until we get enough information to understand the issue, but don't lose hope. Most of the time, you can finally get to the point where you can actually understand what's going on. 

Sometimes, the **bug goes away when we add extra logging information**, or when we follow the code step by step using a debugger. This is an especially annoying type of intermittent issue, nicknamed **Heisenbug**, in honor of Werner Heisenberg. He's the scientist that first described the **observer effect**, where just observing a phenomenon alters the phenomenon.  
Heisenbugs are extra hard to understand, because when we meddle with them, the bug goes away. These bugs usually point to **bad resource management**.  
Maybe the memory was wrongly allocated, the network connections weren't correctly initialized, or the open files weren't properly handled.  
In these cases, we usually need to just spend time looking at the effected code until we finally figure out what's up. Yet another type of intermittent issue is the one that goes away when we **turn something off and on again**. There's plenty of jokes related to how, in IT, a lot of what we do to solve problems, is just turn things off and on again. Okay, it's true that in many cases, power cycling a device or restarting a program gets rid of whichever problem we were trying to fix. But why is that? When we reboot a computer or restart a program, a bunch of things change. Going back to a clean slate means releasing all allocated memory, deleting temporary files, resetting the running state of programs, re-establishing network connections, closing open files and more. 

If a problem goes away by turning it off and on again, there's almost certainly a **bug in the software**, and the bug probably has to do with **not managing resources correctly**. So if an issue goes away after a restart, it's a good idea to try to figure out why that is, and see if it's possible to fix it in a way that doesn't require turning it off and on again. If in the end, we can't find the actual reason, scheduling a restart at a time that's not problematic can also be an option. 

So we've looked at a few ways of getting to the root cause of a problem, like **isolating causes**, **understanding error messages**, **adding logging information**, **and generating new ideas** for possible failures. We've also talked about problems that go away on their own and then pop up again, and looked at how to figure those out. Coming up, we'll check out a practical example of understanding a problem, and how to find its root cause.

### Intermittently Failing Script

A colleague recently developed a small application to send meeting reminders to people in the company, because someone kept forgetting to show up. The sales team was the first to test the app last week, and it worked fine. But this week, another user is trying to send a meeting reminder and the program keeps terminating with an error. Since the colleague that developed the app is on the other side of the Atlantic, the user is asking for our help to figure out what's going on. First, let's try running the program ourselves and check if we can reproduce the problem.  
We're presented with a window where we can enter the date for the meeting, the title of the meeting, and the people that we want to send the reminder to. The meeting reminder that the user was trying to send was for January 13th, and the title was Production Review. As we are trying things out and don't want to be mailing reminders out with our tests, I'll set this one to send the reminders to meet.

It **failed to send the email**. This means we've reproduced the issue. Let's try reminder that the sales team sent last week which had worked fine. In that case, the reminder had been sent for January 7th and the title was Sales All Hands. Again, I'll send this to myself to avoid spanning people would test reminders.
Yes. In this case, the program successfully sent the reminder. Which parameter do you think is at fault? The title or the date? It could be either. But I'll bet it's the date. Let's try it once more with January 13th as the date and Sales All Hands as the title.   
Another failure. So we have a **reproduction case**. When we try to send the meeting reminder for January 13th, we get the failure message. But if we try to send the same reminder for January 7th, it works fine. Now, the next step is to find the root cause of the issue. Why could our application work fine for January 7th but fail for January 13th? There could be a bunch of reasons. But in general, when dates are involved in a failure, **the problem is due to how the dates are formatted**. In some countries, the dates are written with the month first and the day second. While in other countries, it's the other way around. To figure out what's going on, let's add more debugging information to the program. We'll open the **meeting_reminder.sh** script, which is a script written in Bash.

We see that this script is calling a program called Zenity. Zenity is the application showing the window to select the date, title, and emails. The output generated by Zenity is stored in a variable called **meeting_info**, which is then passed as a parameter to the **send_reminders.py**, Python 3 script. This script then sends the emails. To get more information about the output generated by Zenity, **we'd like to see the value of the meeting_info variable** before the Python script gets called. Let's add an echo statement to see that.  
Let's save this and try again. This time, we'll just use test as the meeting title, as we know the problem is with the date.  
We see that the information generated by Zenity is **split by pipes**, and that the data is **formatted as month, day, year**. That's already valuable information. Now, the next step is getting a more informative error. To do that, let's open the Python script that sends the reminders, and see if we can make it print a better error.  
The file is long, so it makes sense to start by looking at the main function that lists the core functionality of the program. We see that it **splits the parameter receive in three**, then prepares the message to be sent, and finally sends it. If everything works fine, it prints a message saying that it was sent successfully. But if anything fails, it prints the error message that we've seen already. But the **error message is not very useful**, as it's hiding the reasons why things failed. Let's make this error more helpful by also printing the exception that generated the failure.  

Let's save and try again.
This time we see that the problem is that the date format we are using is putting the month first, but the **program is expecting to have the month second**. As there's no month 13, this is an invalid date. So we found the root cause of the problem. The program is trying to convert the date assuming one specific date format, but **we're using a different format**. As we now know, once we know the root cause, the **next step is to remediate the issue**.  
What can we do in this case to remediate the problem? We could change the program to use our date format, but then the application would break for people running it in a different location. What we need to do is make sure that no matter where we run the script, the date generated by Zenity matches the date expected by Python. Fortunately, Zenity includes a parameter to specify any format we want.

So we'll change the shell script to use the -- forms-date-format parameter and **set the format to %y -%m-%d,** which is the international standard date format.  
With that, Zenity will return the date in the international format. Now, we need to change the Python script to use the same format. We'll go to the function that has the format specified and **change it to the same format**.  
Great. Now, the date format generated by Zenity should always match the one read by Python. This script should work in our country and any others. Let's try it out and check if it's really fixed.

We've successfully fixed the issue. Let's quickly recap what we did. We first reproduced the problem ourselves, then found which input triggered the issue and which one didn't. We then added more debugging information to the scripts, which helped us find the root cause of the problem, a mismatch between the date formats used by this Zenity invocation and the Python script. Finally, we fixed the issue by making sure that both were using the same date format. Up next, we've got another quiz to check that the concepts we've covered in the last videos are all making sense.

## Binary Searching a Problem

### What is binary search?

Usually when trying to find the root cause of a problem, we'll be looking for **one answer in a list of many**. Searching for an element in a list is a common problem in computing.  
There are a bunch of different algorithms that can help us find the element that we're looking for. Say for example, you have a list that contains the data of employees that work at your company and you want to find one specific employee. One possible approach would be to start from the first entry and then check if the name is the one that we're looking for. If it doesn't match, move to the second element and check again, and keep going until we find the employee with the name we're looking for, or we get to the end of the list. This is called a **linear search**. 

This type of search works but the longer the list, the longer it can take. In other words, the time it takes to find the result is proportional to the length of the list. If the list is sorted, we can use an alternative algorithm for searching called binary search. Because the list is **sorted**, we can make decisions about the **position** of the elements in the list.  
So the first thing we do is **compare** the name that we're looking for with the element in the middle of the list and check if it's **equal, smaller, or bigger**. If it's smaller, we know that the element we're looking for must be in the first half of the list. On the flip side, if it's bigger, we know that it's in the second half of the list. This way, with only one comparison, we've eliminated half of the list from possible candidates where the element could have been found, and then we do the same thing again and again until we find the element. So if the element we were looking for was smaller than the middle element, we look at the element in the middle of the first half. If our element is now bigger, we look at the element in the middle of the second quarter, and so on. 

Each time we **look at the middle element** of the section we're dealing with, until we find the element we're looking for. Using linear search, going through a list with 1000 elements might take up to 1,000 comparisons if the element we're looking for is the last one in the list or isn't present at all. Using binary search for the same list of 1,000 elements, the worst-case is only 10 comparisons. This is calculated as the **base two logarithm** of the lists length, and the benefits get more and more significant the longer the list. For a list of 100,000 elements, it would be 17 comparisons instead of 100,000 comparisons. But remember, that for this to work, the **list needs to be sorted**.  
So if the list isn't sorted, we would need a **sort it first**, which takes a chunk of time. It can still make sense to do it if we're going to search through it several times but it doesn't make sense to sort the list and then use binary search to only find one element. In that case, using linear search is simpler and faster. If you're curious about what these two types of search look like when implemented in Python, you can see a possible implementation of linear search and one for binary search in the next reading. After that, we'll talk about how we can apply the principles of binary search to troubleshooting.

### Applying Binary Search in Troubleshooting

We call that the binary search algorithm. It's really efficient when trying to find an element in a sorted list.  
In troubleshooting, we can apply this idea when we need to go through and **test a long list of hypotheses**. When doing this, the list of elements contains all the possible causes of the problem and we keep **reducing the problem by half** until only one option is left. The list of elements could be **entries in a file, extensions enabled, boards connected to a server, or even lines of code** added to a faulty release. With each iteration, the problem is cut in half. 

This approach is sometimes called bisecting which means dividing in two. In an earlier video, we gave the example of a new version of a program that fail to start when the old configuration directory was present. If the directory contained a bunch of different files in it, we could identify the one causing the failure by bisecting the list of files. Say the old directory contained 12 different config files. We want to identify which of those 12 is causing the failure. To do that, we can create a copy of the directory with just six of the 12 files and then try to start the program again. If it crashes, then the bad file is among those six files. If it doesn't, it's among the other six. In the next step, we would pick three out of the failing group of six. If the program crashes again, it's one of those three. If it doesn't, it's one of the other three. For the last three, we can first check two together or just go one by one. Either way, it's two checks to get to the failing file. This means that with a total of four attempts, we can find out which of the 12 files is causing the problem. 

Since things in IT can sometimes be complex and intertwined, before declaring victory, we want to verify that the program crashes with that single file present and doesn't crash when the single file isn't present. Once we've confirmed that, we've reduced the reproduction case of our problem to a single file instead of a whole directory much easier to understand and figure out what's going on.  
After that, we can proceed **in the same way with the contents of that single file**, cutting it in half repeatedly, until we find the specific part of the file that's causing the problem. The same process can be applied to a large variety of problems. It's very common for example to use it to figure out which **browser extension is causing the browser to crash**, disabling half of the extensions then checking if the browser crashes with that subset and so on until we find the faulty extension. 

We can also use this technique to discover **which plug-in** in a desktop environment is causing the computer to run out of memory, or **which entry in a database** is causing the program to raise an exception. We can also apply this to code when trying to find a bug that was introduced in a recent version.  
If we know the list of changes that were made between one version and the next, we can keep cutting that list in half until we find the one that caused the failure. When using Git for version control, we can use a Git command called **bisect**. Bisect receives two points in time in the Git history and repeatedly lets us try the code at the middle point between them until we find the commit that caused the breakage. This doesn't even need to be your Git repository. If you're using open source software that's tracking Git, you can use the bisect commit to find out which command cause the software to stop working on your computer. For example, if the latest release of the Linux kernel causes the sound card on your computer to stop working, you can use Git bisect to find the commit that broke it and report this as a bug to be fixed. 

As we called out when we were talking about binary search, the **longer the list of items that needs to be checked, the more we'll gain** by cutting our problem in half on each iteration. If it's just five options that need to be checked, we can simply go one-by-one. It won't make a lot of difference and it might be easier to keep track of what we tried. But if it's a 100, we definitely want to bisect the problem so we can find the answer in seven steps. Not a 100. When we have to test a bunch of different options to find the one that's causing a failure, we'll want a quick and easy way to check it. Even if we're reducing the amount of attempts by bisecting the problem, we don't want to spend a long time on each check. Sometimes it's straightforward. Either the program starts or it fails. But other times, it can take a bunch of manual steps to check what we want to check. So depending on what the problem is that we're trying to find, it might make sense to spend some time creating a script that checks for the issue. Up next, we'll see this in action in a practical example

### Finding Invalid Data

We have discussed how we can quickly find out the reason for a problem in a list of possible reasons by splitting the problem in half and testing each half separately. Let's see this in action with an example. We have a program that reads data from a CSV file, processes it, and then imports it into a database. One of the users of the system tells us that the file they're trying to import fails with an obscure **import error**. They've sent us the file so we can try it ourselves. 

To call the command, we'll connect the output of `cat contacts.csv`, the file that the user sent us, to the import.py command. But before we run the command, it's a good time to remember that **we shouldn't test in production**. And since this script is going to be trying to import data into a database, we should run it against the test database instead of the production database. To do that, we'll use the `--server` flag that takes the name of the database server, and then we'll pass the test as the parameter.

We see that the file fails with an importing error, and doesn't give us a lot of information about what's failing. And how big is that file? We could open it with an editor and check, but we don't need to. We can use the `wc` command that counts characters, words, and lines in a file. In particular, `wc -l` will print the amount of lines in a file.  
So our file has 100 lines in it, that's a lot. We don't want to have to go looking through that list to find out what could be wrong, especially since we have no idea what that might be. Instead, we can try passing only half of the file to the **script** and check if it succeeds or fails. If it fails, then we pick up that part of the file and check again with half of it.

If our import succeeds, then we take the other half and split it in two. We could edit the file manually to add or remove the parts as needed, but that would be tedious. Instead, we can use the tools available to us to help us do that with less effort. We can use the head command to print the first lines in the file, and the tail command to print the last lines. We can pass the amount of lines we want to include as a parameter. So `head -15` will print the first 15 lines, while `tail -20` will print the last 20 lines. Okay, and as we saw earlier, our command reads the file to import from standard input. So we can use pipes to connect the output of our head or tail commands to it. Let's try to input the first half of the file now.

Okay, so the first half failed, let's split it again. To do that, we'll use another pipe to take only half of the previous number. This way, in each step, we'll add a call to head or tail for the corresponding size.
This time, it succeeded, hooray. This means that the failure must be in the second quarter of the file. Let's verify that that's the case by giving that part to our command. To do that, we'll take the first half using head, then get the second half of it using tail.  
This fails again, but that's good, it means we're on the right track. Let's split it once again.  
Great, our test set is getting smaller, let's split it once more.  
Okay, we're down to six entries, and we know that one of them is the bad one. Let's spin it one more time, and then we can look at the three remaining entries.  
All right, let's look at the three entries left and see if we can find the culprit.

Can you see the problem? This is a **comma separated file**. This means that each comma is used as a separator between the fields in the file. If a **field includes commas**, it should be written between quotes. But in the case of the third line we're looking at here, we can see that there's a comma instead of a period after the middle initial, and this is not written between quotes. The importing script is then confused because there are too many fields in this line. Okay, let's edit the file and fix it.

And now let's run our importer again with the fixed file.
Yay, we fixed the problem in the file. Using the bisect method, we very quickly found which line out of 100 lines contained the corrupt data. And then we could fix it and successfully import it. The **short-term remediation** here is to tell our user about what we found and how to fix it, so that they can import the data into the production database. The **long-term remediation** is to figure out why the file was generated with the invalid field in the first place, and make sure that it doesn't happen again. Coming up, another practice quiz to help put your bisecting knowledge into action.

## Module Review

Congrats on making it to the end of the module. You're sure learning a lot that'll open up a lot of doors in your IT career. Over the past videos, we learned the general principles of debugging and troubleshooting. 

We looked into the basic process of solving a technical problem like getting information, finding the root cause, and implementing the remediation. 

We learned about a bunch of different tools and techniques that we can use to better understand what's going on with our systems and our programs, including how to create a reproduction case, how to find the root cause for problem, and how to deal with issues that only appear occasionally. 

Finally, we learned about the binary search algorithm, and how we can use it to bisect a problem and quickly find the root cause of a technical problem. All along, we've checked out a bunch of real-world examples, and seen how we can apply this to lots of different types of problems, like a bug in our code, a bug in someone else's code, a configuration issue, or even a hardware problem. It's been great sharing all these interesting stories and examples with you. I hope you're starting to have fun learning more about how to understand problems and find solutions. 

Next time you need to solve a technical problem, try to use some of these steps we outlined and the ideas we talked about. Remember that **logs are your best friend**, and use all the resources available to you, including looking things up on the Internet, and asking colleagues or friends for help. Throughout the rest of this course, we'll keep exploring scenarios that deal with specific problems, like our computer being slow or crushing unexpectedly. We'll keep applying the techniques we've explained in this module to solve those issues. So you can expect a lot more practice. 

Speaking of practice, up next is the graded assessment, which lets you try your hand at solving an actual problem. For the graded assessments in this course, we'll use the Qwiklabs online learning platform, which is powered by the Google Cloud Console. This platform lets you experience real-world scenarios, where you're the one in charge of solving the problems. To interact with the labs, you'll connect to virtual machines running in the Cloud. Each lab will present a different problem that needs solving, and you'll get a chance to practice your new skills and solve the problem. Exciting, right? Remember that if anything isn't clear, you can always go back and re-watch the videos. When you're ready, the lab is waiting for you. You've got this.

# Week 2

## Understanding Slowness

Welcome back, and congrats on making it through that tricky lab that wrapped up the first module. Feels good to have solved an actual problem and get the computer working again, right? Personally, one of the things I love about my job is being able to take control of the system and make it do what I want it to do. Remember that if things don't work right away, it's totally fine. The more you try your hand at solving problems, the easier you'll come up with possible solutions. 

A problem that we have to deal with a lot when working in IT, is **things being slow**. This could be our computer, our scripts, or even complex systems. Slow is a relative term. Modern computers are much faster and can do many more things than computers a couple of decades ago. Still, we always want them to be faster and to do more in less time.  
With modern day computers it might seem that our resources are unlimited, but if we try hard enough we can hit the limits. For example, if you're browsing the internet and you open a new tab in your browser, it might seem like it doesn't take any resources at all. It's just a click and you have a new tab available. But if you keep opening tabs, at some point your computer will become sluggish. Depending on the hardware of the computer and what other programs are running, it might take 100 or more open tabs to get there. But eventually, you'll run out of memory and everything will slow down. 

There's a bunch of different things we can do if our system is too slow. The most obvious one is **closing any applications we don't need at the moment**. This works because it helps us free some of the resources in our computer, like CPU time, RAM, or video memory. That way the program that we want to run faster will have access to more of these resources. When closing applications that we don't need we might even need to look at applets, plugins, extensions, or other small programs that might seem harmless, as they take some resources to run. On top of that, closing any other elements that take resources, like browser tabs or open files in a document editor, can also help. 

But this only gets us so far because there's a ton of other reasons why our devices or programs might be slow. Over the course of the next few videos we'll do a rundown of the different reasons that can make things run slowly. We'll look into what causes **slow scripts, slow computers, or slow systems**. We'll give you the tools to help you identify the most common causes of slowness, and apply solutions to improve the overall performance. We've got a lot to cover, but don't worry will guide you through everything and we'll take it slow.

### Why is my computer slow?

Our computers execute thousands of millions of instructions per second. Each of those instructions does one small thing, like incrementing a value, comparing two values, or moving a value from one place to another. Still with thousands of millions of instructions per second, there's a lot that a computer can do in just one second. This allows our computer to seemingly execute a number of different thing at the same time. Say you're browsing the web while also running an application that plays your favorite music in the background. Even if your computer has a single core to execute those applications, it will seem like the computer is running these two programs at the same time. 

What's happening under the hood is that each application gets a fraction of the CPU time, and then the next application gets a turn. Most of the time this works fine. But if you run too many applications or if one of these applications were running needs more CPU time than the fraction it's getting, things might become frustratingly slow. The general strategy for addressing slowness is to **identify** the [inaudible] for addressing slowness in our device, our script, or our system to run slowly. The bottleneck could be the CPU time as we just mentioned. But it could also be **time spent reading data from disk waiting for data transmitted over the network**, moving data from disk to RAM, or some other resource that's limiting the overall performance. Pretty often, we can speed things up and getting rid of anything else that's using resources on the same computer. 

So if the problem is that your program needs more CPU time, you can close other running programs that you don't need right then. If the problem is that you don't have enough space on disk, you can uninstall applications that you don't use, or delete or move data that doesn't need to be on that disk. If the problem is that the application needs more network bandwidth, you can try stopping any other processes that are also using the network and so on. This only helps us if the issue is that there are too many processes trying to use the same resource. If we've closed everything that wasn't needed and the computer is still slow, we need to look into other possible explanations. What if the hardware we're using just isn't good enough for the applications we're trying to run on it? In cases like these, will have to upgrade the underlying hardware. 

But to make a difference in the resulting performance, we need to make sure that we're actually improving the bottleneck and not just wasting our money on new hardware that will go unused. So how can we tell which piece of hardware needs to be changed? We need to monitor the usage of our resources to know which of them as being exhausted. This means that it's being used completely and programs are getting blocked by not having access to more of it. Is it the CPU, the memory, the disk IO, the network connection, the graphics card? To find out, we use the tools available in our operating system, monitor the usage of each resource, and then work out which one is blocking our programs for running faster. We've already talked about using `top` on Linux systems. This tool lets us see which currently running processes are using the most CPU time. If we start by memory, which ones are using the most memory. It also shows a bunch of other load information related to the current state of the computer, like how many processes are running and how the CPU time or memory is being used. 

We also called out in earlier videos a couple of other programs like `iotop` and `iftop`. They can help us see which processes are currently using the **most disk IO usage** or the most network bandwidth. On MacOS, the OS ships with a tool called **Activity Monito**r which lets us see what's using the most CPU, memory, energy, disk, or network. On Windows, there's a couple of OS tools called **Resource Monitor** and Performance Monitor which also let us analyze what's going on with the different resources on the computer including CPU, memory, disk and network. 

So if you're looking to diagnose what's causing your computer to run slow, the first step is always to open one of these tools. Check out what's going on, and try to understand which resources the bottleneck and why. Then plan how you're going to solve the issue. Of course, not all performance problems are solved by closing applications are getting better hardware. Sometimes, we need to figure out what the software is doing wrong and where it's spending most of its time to understand how to make it run faster. We need to really study each problem to get to the root cause of the slowness. Up next, we'll talk about some ideas to help us better understand what's going on under the hood.

### How Computers Use Resources

In the last video, we called out how a computer can be constrained by different resources like CPU, disk, memory, or network. We discussed how we need to eliminate the bottlenecks and get our computer to better use its resources to boost our system's performance. To do that, we need to **understand how each component interacts with the other** and what the limitations are. In particular, when thinking about making things faster, it's important to understand the different speeds of the parts involved. When an application is accessing some data, the time spent retrieving that data will depend on where it's located. 

If it's a variable that's currently being used in a function, the data will be in the CPU's internal memory, and our program will retrieve it really fast.  
If the data is related to a running program but maybe not the currently executing function, it will likely be in RAM, and our program will still get to a pretty fast.  
If the data is in a file, our program will need to read it from disk, which is much slower than reading it from RAM, and worse than reading from disk, is reading information from over the network. In this case, we have a lower transmission speed, and we also need to establish the connection to the other endpoint to make the transmission possible, which adds to the total time needed to get to the data. 

So if you have a process that requires repeatedly reading data over the network, you might want to figure out if you can read it once stored on disk, and then read it from disk afterwards. Or similarly, if you repeatedly reading files from disk, you might see if you can put the same information directly into the process memory and avoid loading it from disk every time. In other words, you want to consider if you can create a **cache**, a cache stores data in a form that's faster to access than its original form. There's a ton of examples of caches in IT. **A web proxy is a form of cash**. It stores websites, images, or videos that are accessed often by users behind the proxy. So they don't need to be downloaded from the Internet every time.  
DNS services usually implement a local cache for the websites they resolve. So they don't need to query from the Internet every time someone asks for their IP address. The operating system also takes care of some caching for us.  
It tries to keep as much information as possible in RAM so that we can access it fast. This includes the contents of files or libraries that are accessed often, even if they aren't in use right now. We say that these contents are cached in memory. We call that that if the data is part of a program that's currently running, it will be in RAM. But RAM is limited. If you run enough programs at the same time, you'll fill it up and run out of space. What happens when you run out of RAM? At first, the **OS will just remove from RAM anything that's cached**, but not strictly necessary. 

If there's still not enough RAM after that, the operating system will put the parts of the memory that aren't currently in use onto the hard drive in a space called swap. Reading and writing from disk is much slower than reading and writing from RAM. So when the swapped out memory is requested by an application, it will take a while to load it back. The swapping implementation varies across the different operating systems, but the concept is always the same. The information that's not needed right now is removed from RAM and put onto the disk, while the information that's needed now is put into RAM. This is normal operation, and most of the time, we don't notice it. But if the available memory is significantly less than what the running applications need, the OS will have to keep swapping out the data that's not in use right now to move the data currently in use to RAM, and as we called out, our computer can switch between applications very quickly, which means that the **data currently in use can also change very quickly**. 

The computer will start spending a lot of time writing to disc to make some space in RAM and then reading from disk to put other things in RAM. This can be super slow. So what do you do if you find that your machine is slow because it's spending a lot of time swapping? There are basically three possible reasons for this. We've already talked about two of them. First, if there are too many open applications and some can be closed, close the ones that aren't needed. Or if the available memory is just too small for the amount that computer is using, add more RAM to the computer. The third reason is that one of the running programs may have a **memory leak**, causing it to take all the available memory. A memory leak means that memory which is no longer needed is not getting released. We'll talk a bunch more about memory leaks later in the course. For now, let's just say that if a program is using a lot of memory and this stops when you restart the program, it's probably because of a memory leak. Up next, we'll discuss a bunch more different reasons our computer might run slowly and what we can do to fix them.

### Possible Causes of Slowness

We've talked about a few different things that can make our computer slow. But of course, there's a lot more possible reasons. In this video, we'll do a rundown of some of the most common ones that you might come across in your IT role. Before we do, a quick reminder that when trying to diagnose why a computer is slow, we should use the process of elimination that we looked at earlier. We first look for the **simplest explanations** that are the easiest to check. And after eliminating a possible root cause, we go back to the problem and come up with the next possible cause to check. So when trying to figure out what's making a computer slow, the first step is to look into when the computer is slow. If it's slow when starting up, it's probably a sign that there are too many applications configured to start on boot.

In this case, fixing the problem is just a question of going through the list of programs that start automatically and disabling any that aren't really needed. If instead the computer becomes sluggish after days of running just fine, and the problem goes away with a reboot, it means that there's a program that's keeping some state while running that's causing the computer to slow down.  
For example, this can happen if a program stores some data in memory and the data keeps growing over time, **without deleting old values**. If a program like this stays running for many days, the data might grow so much that reading it becomes slow and the computer runs out of RAM. This is almost certainly a bug in the program. And the ideal solution for a problem like this is to change the code so that it frees up some of the memory used. If you don't have access to the code, another option is to schedule a regular restart to mitigate both the slow program and your computer running out of RAM.  

A similar problem that can trigger after a long time using an application, and that isn't solved by a reboot, is that the files that an application is handling have **grown too large**. So when the program needs to read those files, it gets really slow. Again, this generally points to a bug in the way the program was designed because it didn't expect the files to grow so large. The best solution in this case is to fix the bug.  
But what can you do if you can't modify the code of the program? You can try to reduce the size of the files involved. If the file is a log file, you can use a program like logrotate to do this for you. For other formats, you might need to write your own tool to **rotate the contents**. Another data point that we can use to diagnose what's going on is whether this happens for all users of the application or just a **subset of them**. 

If only some users are affected, we'll want to know if there's something that's **configured differently** on those computers that might be triggering the slowness. For example, many operating systems include a feature that tracks the files in our computer so it's easy and fast to search for them. This feature can be really useful when looking for something on a computer, but can get in the way of everyday use if we have tons of files and not the most powerful hardware.  
We've called out before that reading from the network is notably slower than reading from disk. It's common for computers in an office network to use a file system that's mounted over the network so they can share files across computers. This normally works just fine, but can make some programs really slow if they're doing a lot of reads and writes on this network-mounted file system. To fix this, we'll need to make sure that the directory used by the program to read and write most of its data is a directory local to the computer. 

**Hardware failures** can also cause our computer to become slow. If your hard drive has errors, the computer might still be able to apply error correction to get the data that it needs, but it will affect the overall performance. And once a hard drive starts having errors, it's only a matter of time until they're bad enough that data starts getting lost, so it's worth keeping an eye out for them. To do this, we can use some of the OS utilities that diagnose problems on hard drives or on RAM, and check if there's anything that could be causing problems.  
Yet another source of slowness is **malicious software**. Of course, we always want to keep your computer clean of any malicious software, but we can feel the effects of malicious software even if they aren't installed. For example, you might have come across a website that includes scripts, either in the website's content or the ads displayed, that use our processor to mine for cryptocurrency. Malicious browser extensions also fall into this category.  
As you can see, there's a lot of possible reasons that could cause our computer to run slowly. Whenever we have to fix an issue like this, we need to look at what the bottleneck is, figure out the root cause behind the resource being used up, and then take appropriate action. Up next, we'll do a practical exercise of figuring out why our computer is slow and solving the issue.

### Slow Web Server

A user has alerted us that one of the web servers in our company is being slow, and we need to figure out what's going on. Let's start by navigating to the website and loading the page.  
Okay. We see that the page loads. It seems to be a little slow but it's hard to measure this on our own. Let's use a tool called **ab** which stands for Apache Benchmark tool to figure out how slow it is.  
We'll run `ab -n 500` to get the average timing of 500 requests, and then pass our `site.example.com` for the measurement. This tool is super useful for checking if a website is behaving as expected or not. It will make a bunch of requests and summarize the results once it's done. Here, were asking for it to do 500 requests to our website. There are a lot more options that we could pass like how many requests we want the program to do at the same time, or if the test to finish after timeout, even if not all requests completed, we're making 500 requests so that we can get an average of how long things are taking.  
Once the test finishes, we can look at the data and decide if it's actually slow or not. All right. The tool has finished running the 500 requests. We see that the mean time per requests was a 155 milliseconds. While this is not a super huge number, it's definitely **more than what we'd expect** for such a simple website. It seems that something is going on with the web server and we need to investigate further. Let's connect to the web server and check out what's going on.

We'll start by looking at the output of `top` and see if there's anything suspicious there.
We see that there's a **bunch of ffmpeg processes** running, which are basically using all the available CPU. See those load numbers? Thirty is definitely not normal. Remember that the **load average on Linux shows how much time the processor is busy at a given minute** with one meaning it was busy for the whole minute. This computer has two processors. So any number above two means that it's overloaded. During each minute, there were more processes waiting for processor time than the processor had to give. This **ffmpeg** program is used for video transcoding which means converting files from one video format to another. This is a CPU intensive process and seems like the likely culprit for our server being overloaded. So what can we do? One thing we can try is to change the processes priorities so that the web server takes precedence. 

The process priorities in Linux are so that the **lower the number, the higher the priority**. Typical numbers go from 0 to 19. By default, processes start with a priority of zero. But we can change that using the nice and renice commands. We use nice for starting a process with a different priority and renice for changing the priority of a process that's already running. Okay. Let's exit top with queue and change the priorities. We want to run renice for all the ffmpeg processes that are running right now. We could do this one by one. But it would be manual, error-prone, and super boring. Instead, we can use a quick line of shell script to do this for us. For that, we'll use the `pidof` command that receives the process name and returns all the process IDs that have that name.  We'll iterate over the output of the pidof command with a for loop and then call renice for each of the process IDs. Renice takes the new priority as the first argument, and the process ID to change as the second one. In our case, we'll want the lowest possible priority which is 19. So we'll call for pid in 

`$(pidof ffmpeg);
do renice 19 $pid; done`. 

All right. We see that the priorities for those processes were updated. Let's run our benchmarking software again and check out if it made any difference.  

Okay. It's running once again. We'll need to wait until the 500 requests are done and check out the new meantime per request value. This time, the meantime is 153 milliseconds. It doesn't seem like our renice helped. Apparently, the OS is still giving these ffmpeg processes way too much processor time. Our website is still slow. What else can we do? These transcoding processes are CPU intensive, and running them in parallel is overloading the computer. So one thing we could do is, modify whatever's triggering them to run them one after the other instead of all at the same time. To do that, we'll need to find out how these processes got started. First, we'll look at the output of the ps command to get some more information about the processes. We'll call `ps ax` which shows us all the running processes on the computer, and we'll connect the output of the command to `less`, to be able to scroll through it.
Now we'll look for the ffmpeg process using slash which is the search key when using less.

Okay. We see that there are a bunch of ffmpeg processes that are converting videos from the webm format to the mp4 format. We don't know where these videos are on the hard drive. We can try using the locate command to see if we can find them. We'll first exit the less interface with queue and then call locate static/001.webm. We see that the static directory is located in the server deploy videos directory. Let's change into that directory and see what we find.
There's a bunch of files here. We could check them all one-by-one to see if one of them contained a call to ffmpeg. But that sounds like a lot of manual work. Instead, let's use grep to check if any of these files contains a call to ffmpeg.
So we see that there's a couple of mentions in the deployed sh file. Let's take a look at that one. Since we're connecting to the server remotely, we can't open the file using a graphical editor. We need to use a command line editor instead. We'll use vim in this case.

We see that this script is starting the ffmpeg processes in parallel using a tool called **Daemonize** that runs each program **separately as if it were a daemon**. This might be okay if we only need to convert a couple of videos but launching one separate process for each of the videos in the static directory is overloading our server. So we want to change this to run only one video conversion process at a time. We'll do that by simply deleting the daemonized part and keeping the part that calls ffmpeg, then save and exit.
All right. We've modified the file. But this won't change the processes that are already running. We want to stop these processes but not cancel them completely, as doing so would mean that the videos being converted right now will be incomplete. So we'll use the `killall` command with the `-STOP` flag which sends a stop signal but doesn't kill the processes completely.

We now want to run these processes one at a time. How can we do that? We could send the `CONT` signal to one of them, wait till it's done, and then send it to the next one. But that's a lot of manual work. Can be automate it? Yes. But it's a little tricky. So pay close attention. We can iterate through the list of processes using the same for loop with the pit of command that we used earlier.  
Inside the for loop, we want to **send the cont signal and then wait until the process is done**. Unfortunately, there's no command to wait until the process finishes. But we can create a while loop that sends the cont signal to the process. This will succeed as long as the process exists, and fails once the process goes away. Inside this while loop, we'll simply add a call to sleep one, to wait one second until the next check.

Okay. Now our server is running one ffmpeg process at a time. Let's turn our benchmark once more.
The mean time is now 33 milliseconds. That's much lower than before. We've managed to get our web server to reply promptly to the request again. We've mentioned a few different approaches that we can take when we can't fix the code like renicing the processes, or running them one after the other when that doesn't help. In our next few videos, we'll talk about how to improve performance by fixing our code. But before that, there's a reading to put all the resources we mentioned in one place, and then a quick quiz to check if everything is making sense.

## Slow Code

### Writing Efficient Code

In your role as an IT specialist or systems' administrator, you'll likely need to write scripts to automate tasks. A piece of code may start as a simple script that does a single thing, but **end up growing into a complex program** that handles many different tasks, and no matter the size and complexity of our code, we usually want it to perform well. In this and the next few videos, we'll discuss some ideas for how to make our code more efficient and how to figure out what needs fixing if it's slow.  
One important thing to keep in mind though is that we should always start by **writing clear code that does what it should** and only try to make it faster if we realize that it's not fast enough. If it takes you 10 minutes to write a script that will run in five seconds, and 20 minutes to write a script that will do the same but takes three seconds, does it make a difference? 

It all depends on how often you run the script. If you run it once a day, the two seconds deference definitely won't justify the additional 10 minutes of work. But if you're going to run the same script for the 500 computers on your network, that small difference means it will take 15 less minutes to run the whole script. So overall, you're gaining time. Of course, it's pretty hard to know in advance how fast your script will be and how long it will take you to make it faster. But as a rule, we aim first to write code that's readable, easy to maintain and easy to understand, because that lets us write code with less bugs. If there's something that's super slow, then yes, it makes sense to fix it, particularly if the script will be executed frequently enough that making it faster will save you more time than the time you spend optimizing it. 

But remember, trying to optimize every second out of a script is probably not worth your time. Okay, with that said, let's dive into how we can make our code more efficient. The first step is to keep in mind that we **can't really make our computer go faster**. If we want our code to finish faster, we need to make our computer do less work, and to do this, we'll have to avoid doing work that isn't really needed. How? There's a bunch of different things to do. The most common ones include **storing data that was already calculated** to avoid calculating it again using the **right data structures** for the problem and reorganizing the code so that the computer can stay busy while waiting for information from slow sources like disk or over the network. To know what sources of slowness we need to address, we have to figure out where our code is spending most of its time. 

There's a bunch of tools that can help us with that called **profilers**. A profiler is a tool that measures the resources that our code is using, giving us a better understanding of what's going on. In particular, they help us see how the memory is allocated and how the time spent. Because of how profilers work, they are specific to each programming language.  
So we would use **gprof** to analyze a C program but use the **c-Profile module** to analyze a Python program. Using tools like these, we can see which functions are called by our program, how many times each function was called and how much time are programs spent on each of them. This way we can find for example, that our program is calling a function more times than we originally intended or that a function that we thought would be fast is actually slow. To fix our code, we'll probably need to restructure it to avoid repeating expensive actions. What do we mean by expensive? In this context, **expensive actions are those that take a long time to complete**. Expensive operations include **parsing a file, reading data over the network or iterating through a whole list**. Okay. How do we modify our code to avoid expensive operations? We'll discuss a few strategies in our next videos.

### Using the Right Data Structures

Having a good understanding of the data structures available to us can help us avoid unnecessary expensive operations and create efficient scripts. In particular, we'll want to understand the performance of those structures under different conditions. In the introductory course to Python, you learned about a bunch of different data structures available in Python like **lists**, **tuples**, **dictionaries**, and **sets**. Each of them have their uses, their advantages, and disadvantages. 

Let's do a very quick recap of lists and dictionaries. **Lists are sequences of elements**. We can add, remove, or modify the elements in them. We can iterate through the whole list to operate on each of the elements. Different programming languages call them differently. The structure is called ArrayList in Java, Vector in C++, Array in Ruby, and Slice in Go. All these names refer to the same data structure that's **fast to add or remove elements at the end**.  
But adding or removing elements **in the middle can be slow** because all the elements that follow **need to be repositioned**. It's fast to access the element in a specific position in the list, but finding an element in an unknown position requires going through the whole list. This can be super slow if the list is long. 

**Dictionary store key-value pairs**. We add data by associating a value to a key. Then, we retrieve a value by looking up a specific key. They are called HashMap in Java, Unordered Map in C++, Hash in Ruby, and Map in Go. The map part in those names comes from how we're creating a **mapping between a key and a value**. The Hash part comes from the fact that to make the structure efficient, a **hashing function is used internally to decide how the elements will be stored**.  
The main characteristic of this structure is that it's **super-fast for looking up keys**. Once we have our data stored in a dictionary, we can find the value associated to a key in just one operation. If it were stored in a list, we need to iterate through the list.  
So as a rule of thumb, if you need to access elements **by position** or will always iterate **through all the elements**, use a **list** to store them. This could be a list of all computers in the network, of all employees in the company, or of all products currently on sale for example. 

On the flip side, if we need to **look up the elements using a key, we'll use a dictionary**. This could be the data associated to a user which we'd look up using their username, the IP associated to a computer using the host name, or the data associated to a product using the internal product code. Whenever we need to do a bunch of these lookup operations, creating a dictionary and using it to get the data will take a lot less time than iterating over a list to find what we're looking for. But it doesn't make sense to create a dictionary and fill it with data if we're only going to look up one value in it. In that case, we're wasting time creating the structure when we could just iterate over the list and get the element we're looking for. 

Another thing that we might want to think twice about is **creating copies of the structures** that we have in memory. If these structures are big, it can be pretty expensive to create those copies. So we should double-check if the copy is really needed. All right. Now, that we have a better understanding of when to use each data structure and what actions to avoid, we can look into how to deal with expensive loops. That's coming up in our next video.

### Expensive Loops

Loops are what make our computers do things repeatedly. They are an extremely useful tool and let us avoid repetitive work, but we need to use them with caution. In particular, we need to think about what actions we're going to do inside the loop, and when possible, avoid doing expensive actions.  
If you do an expensive operation **inside a loop**, you **multiply the time** it takes to do the expensive operation by the amount of times you repeat the loop. Say for example that you're writing a script to send an email to all the employees at your company asking them to verify that their emergency contact information is still valid. To send this out, you'll have a loop that sends one email per employee. In the body of the email, you'll include the current emergency contact data. The interesting part is how you access the data inside the loop. If the data is stored in a file, your script will need to parse the file to fetch it. If the script reads the whole file for every user, you'll be wasting a lot of time parsing the file over and over unnecessarily. 

Instead, you could parse the file outside of the loop, put the information into a dictionary, and then use the dictionary to retrieve the data inside the loop. Whenever you have a loop in your code, make sure to check what actions you're doing, and see if there are operations you **can take out of the loop** to do them **just once**.  
Instead of making one network call for each element, make one call before the loop. 
Instead of reading from disk for each element, read the whole thing before the loop. Even if the operations done inside the loop aren't especially expensive, if we're going through a list of a thousand elements and we only need five out of them, we're wasting time on elements we don't need. Make sure that the list of elements that you're iterating through is only as long as you really need it to be. 

Let's say you're running an internal website. As part of the information the site shows, it displays a list of the last five users that logged in. In the code, the program keeps a list of all the users that have logged in since it last started, and when the program needs to display the five latest users, it goes through the whole list and finds out which of those are the five most recent. This wastes a lot of time. If the service has been running for a while, it can take really long to go through the whole list. Instead, you could modify the service to store the user access info **in log files that can be read if necessary and only keep the last five logins in memory**. Whenever a new user logs in, the oldest entry in the list gets discarded and a new one gets added. That way, the script doesn't need to go through the whole list every time it needs to display the five most recent users. 

Another thing to remember about loops is to **break out of the loop once you found what you were looking for**. In Python, we do this using the keyword break. Breaking out of loops means that as soon as the data we're looking for is found, our script can continue. Of course if the data is at the end of the list, then we need to go through the loop anyway. But when the data is at the beginning of the list and not at the end, it makes sense to have our code break early to make the script faster. Say you're writing a script that checks if a given username is within the list of authorized entities, and if it is, it grants them access to a particular resource. You can use a for loop to iterate through the list of entities. When the username is found, you can break out of the loop and continue the rest of the script. One last thing to keep in mind is that the right solution for one problem might not be right for a different problem. Say your service has a total of 20 users. In that case, it's okay to go over this list whenever you want to check something. It's short enough that you don't need to do any special optimization. But if your service has over a thousand users, you'll want to avoid going through that list unless absolutely necessary. If the service has hundreds of thousands of users, going through that list isn't even a possibility. Up next, we'll talk about what we can do when the expensive operations are already outside of our loops.

### Keeping Local Results

In our last video, we talked about how to avoid having expensive operations inside our loops. So if we have to parse a file, we do it once before we call the loop instead of doing it for each element of the loop. But what if parsing the file is taking a lot of time even when it's done outside of the loop? Remember that to make our scripts get to their goal faster, we need to avoid having our computer do unnecessary work.  
So how can we avoid expensive operations like parsing a file, downloading data over the network, or going through a long list? If the script gets executed fairly regularly, it's common to **create a local cache**. In an earlier video, we said that a cache is a way of storing data in a form that's faster to access than its original form. 

So if we're parsing a large file and only keeping a few key pieces of information from it, we can create a cache to **store only that information**, or if we're getting some information over the network, we can keep a **local copy** of the file to avoid downloading it over and over again. Creating caches can be super useful to save us time and make our programs faster. But they're sometimes tricky to get right. We need to think about how often we're going to update the cache and what happens if the data in the cache is out of date.  
If we're looking for some long-term stats, we can generate the cache once per day, and it won't be a problem. This might be the case for data like how much memory was used on computers across the fleet over the last month? How many employees each department in a company has? Or how many units were sold of each product over the last quarter? 

But if we're trying to look at data where the value as of right now is super important, we either **can't use a cache** or it has to be **very short-lived**. This could be the case for monitoring the health of computers to alert when something crosses a threshold.  
Checking the stock levels to see if there's enough of a product to sell or seeing if a username already exists in the network when trying to create a new one. Sometimes, we can add a check to validate if we need to recalculate the cache or not. For example, if our cache is based on a file, we could store the modification date of that file when we calculated the cache. Then **only recalculate the cache if the modification date of the file is newer** than the one we had stored.  
If we don't have a way of checking if our cache is out of date or not, we'll need to add in logic to our program that tries to make a sensible decision. For that, we'll take into account how often we expect the data to change, how critical it is that the latest data is used, and how frequently the program that we're running will be executed. After taking all these factors into account, we might decide that the cache needs to be recreated once per day, once per hour, or even once per minute. 

Yes, even once per minute might make sense if you have a script that can get executed several times per minute and needs to do an expensive operation that can be cached. That way, only the first execution in a minute will spend time on this operation, the rest will be very fast. But the **cache is never more than a minute out of date**.  
Keep in mind that caches don't always need to be elaborate structures, storing lots of information with a complex timeout logic. Sometimes, they can be as simple as having a variable that stores a temporary result instead of calculating this result every time we need it. For example, say you're generating a report that prints how many users there are in each of the different groups in the network. Now, some of these groups may contain other groups in them and some groups may even be part of several groups. For example, the Java release engineers group would be part of the release engineers group and the Java developers group. How can we avoid counting unique users more than once if they show up in multiple groups? We can have a dictionary with the group as the key and the amount of users as the value. That way, we only need to count the members of a group once, and after that, just use the value in the dictionary. 

To sum all of this up, remember that you'll want to look for strategies that let you avoid doing expensive operations. First, check if these operations are needed at all. If they are, see if you can store the intermediate results to avoid repeating the expensive operation more than needed. Up next, we'll look into a practical example of how to deal with some code that's running slower than expected.

### Slow Script with Expensive Loop

Remember that meeting reminder script that was having trouble with the dates? The developers has kept working on it. Now, since personalized emails with the name of the person getting email and the greeting. That's cool. But unfortunately it seems to have made the application pretty slow. The developers are asking for our help in figuring out how we can make the program faster. So let's get to work. First, we'll need to reproduce the problem and figure out what slow means in this case. One user told us that the problem is visible when the list of recipients is long.  
To avoid spamming our colleagues while we're testing this issue, we'll send reminders to a bunch of test users that we've created in our mail server. You might remember that the application has two parts. A **shell script** that pops up a window where we can enter the data of the reminder and a **Python script** that prepares the email and sends it. 

The part that's **slow is the sending of the emails**. So we won't interact with the pop-up at all. We'll just pass the parameters we need to the Python script. We'll measure the script speed using the `time` command. Let's first call it with just one test user and see how long it takes.
When we call time it runs the command that we pass to it and prints how long it took to execute it. There's three different values. **Real, user, and sys**.  
**Real** is the amount of actual time that it took to execute the command. This value is sometimes called wall-clock time because it's how much time a clock hanging on the wall would measure no matter what the computer's doing.  
**User** is the time spent doing operations in the user space.  
**Sys** is the time spent doing system level operations. The values of user and sys won't necessarily add up to the value of real because the computer might be busy with other processes. Okay. What do we see here? It took our script 0.129 seconds to send the email. That's not a lot but we only send the message to one user. Let's try this again with our nine tests users. Two test three, test four, test five, test six, test seven, test eight, test nine. All right. We see that it took 0.296 seconds to send the email this time. That's still not a lot but it does look like it's taking longer with a longer list of emails. Okay. It's time to try to make this better. How can we find out what's wrong with the code? 

We could always look at the code and see if we find any expensive operations that we can improve. But in this case we want to use a **profiler** to get some data about what's going on. So let's try that. There's a bunch of different profilers available for Python that work for different use cases. Here, we'll use the one called **pprofile 3**. We use the dash f flag to tell it to use the call grind file format and the dash o flag to tell it to store the output in the profile dot out file. This generated a file that we can open with any tool that supports the call grand format. We're going to use kcachegrind to look at the contents, which is a graphical interface for looking into these files.  
There's a lot going on with this program. So don't get scared if it takes a while to make sense out of it. As with so many other things practicing and tinkering on your own will help you get used to what all the different things here mean. Let's look at the information we need now. In the lower right half we see a call graph, which tells us that the **main function is calling the send message function** one time. This function is calling the message template function, the get name function, and the send message function nine times each. The graph also tells us how many microseconds are spent on each of these calls. We can see that **most of the time is being spent in the get name** function. That's probably the one we should optimize. Let's see what this function is doing using atom.

So we see that the get name function opens a CSV file then goes through the whole file checking if the first field in the line matches the e-mail name and when that's the case it sets the value of the name variable. There's a couple of things that are wrong with this function.  
First, once it finds the element in the list it **should immediately break out of the loop**. Right now, it's iterating through the whole file even if the email was found in the first line. But even if we fixed that it would still open the file and read through it for each e-mail address.  
This can get really slow if the file has a lot of lines. 

So how can we make this better? We can read the file once and store the values that we care about in a **dictionary** and then use that dictionary for the lookups. Let's do that. We'll change the get name function and turn it into a read names function that will process the CSV file and store the values we want in the names dictionary. For each line will store the email as the key and the names as the values. Instead of returning one name we'll return the whole dictionary.  
All right we have a read names function that stores the data we want in a dictionary. We now need to change the way this is called in the send message function. We see that the **get name function** is being called **once per email**. To apply our change we should call the read names function before the for loop so that we do it only once. Then instead of calling get name we'll just get the values form the dictionary.
All right we've made the change. Let's save our file and profile our script again to see if we manage to make it any faster.

The graph looks different now as we've changed how the code behaves. See how the read names function is now taking a much smaller portion of time. On the flip side we see that the message template is the one that's taking the most time now. So if we wanted to keep making our script faster that's what we look next. In this video, we saw that we can use the time command to check how long it takes to execute a program. We then saw how we can combine a profiler and a profile visualizer to figure out where our code is spending most of his time. Finally, we changed our code to avoid doing inexpensive loop over and over by storing the information in a dictionary and then accessing the dictionary instead. Up next there's a reading with more information about profiling and after that a practice quiz to check if this is all still making sense.

## When Slowness Problems Get Complex

### Parallelizing Operations

We've called that a few times already, that reading information from disk or transferring it over the network is a slow operation. In typical scripts while this operation is going on, nothing else happens. The script is **blocked**, waiting for input or output while the CPU sits idle.  
One way we can make this better is to **do operations in parallel**. That way, while the computer is waiting for the slow IO, other work can take place. The tricky part is dividing up the tasks so that we get the same result in the end. There's actually a whole field of computer science called **concurrency**, dedicated to how we write programs that do operations in parallel. We won't go into a ton of details here but we'll give you a brief overview of what you can do. First, we need to understand what the operating system already does for us. Our OS handles the many processes that run on our computer. If a computer has more than one core, the operating system can decide which processes get executed on which core, and no matter the split between cores, all of these processes will be executing in parallel. Each of them has its own memory allocation and does its own IO calls. The OS will decide what fraction of CPU time each process gets and switch between them as needed. 

So a very easy way to run operations in parallel is just to **split them across different processes**, calling your script many times each with a **different input set**, and just **let the operating system handle the concurrency**. Let's say you want to collect statistics on the current load and memory usage for all the computers in your network. You can do this by writing a script that connects to each computer in a list and gets the stats. Each connection takes a while to complete, so the total run-time of the script would be the sum of the time taken by all those connections. Instead, you could split the list of computers into smaller groups and use the OS to call the script many times once for each group. That way, the connections to the different computers can be started in parallel, which minimizes the time but the CPU isn't doing anything. This is super easy to do and for many scripts, it'll be the right choice. 

Another easy thing to do, is to have a good balance of different workloads that you run on a computer. If you have a process that's using a lot of CPU while a different process is using a lot of network IO and another process is using a lot of disk IO, these can all run in parallel without interfering with each other. When using the OS to split the work and the processes, these processes **don't share any memory**, and sometimes we might **need to have some shared data. In that case, we'd use threads**. **Threads** let us run **parallel tasks inside a process**. This allows threads to **share some of the memory** with other threads in the same process. Since this isn't handled by the OS, we'll need to modify our code to create and handle the threats. For that, we'll need to look into how the programming language we're using implements threading. In Python, we can use the **Threading** or **AsyncIO** modules to do this. These modules let us specify which parts of the code we want to run in separate threads or as separate asynchronous events, and how we want the results of each to be combined in the end. We won't go into the details of how you can do that here, but we'll link to more information on this in the next reading. One thing to watch out for is that depending on the actual threading implementation for the language you're using, it might happen that **all threads get executed in the same CPU processor**. In that case, if you want to use more processors, you'll need to split the code into fully separate processes. If your script is mostly just waiting on input or output, also known as I/O bound, it might matter if it's executed on one processor or eight. But you might be doing this in parallel because you're using all of the available CPU time. In other words, your script is CPU bound. In this case, you'll definitely want to split your execution across processors. 

Now there's a point where adding more parallel processes means things become even slower, not faster. If we're trying to read a bunch of files from disk and do too many operations in parallel, the disk might end up spending more time going from one position to another then actually retrieving the data, or if we're doing a ton of operations that use a lot of CPU, the OS could spend more time switching between them than actually making progress in the calculations we're trying to do.  
So when doing operations in parallel, we need to find the right balance of simultaneous actions that let our computers stay busy without starving our system for resources. I recently felt the benefits of applying concurrency. I was working on migrating data that was stored in one format, and I needed to store it in a different format. There were a lot of gigabytes of data that needed migrating, so of course I wasn't going to do it manually. My first version of the script was taking an average of one hour per gigabyte migrated. This was much slower than I expected, so I decided to spend more time tweaking the code to make the migration go faster. I reorganized the logic to have a separate thread per file which decreased the total time to work through the files since it now wasn't a linear process, and then, to make it go even faster, I split the work onto different machines, each running a bunch of threads.  
After all this rearranging to use the resources I have, I brought it down to three minutes per gigabyte. Yeah, we may be learning a lot about slowness, but we sure are moving fast. Some of these concepts may feel a little complex and it's perfectly normal. Take your time, everyone learns slowness at their own pace. Up next, we'll discuss the different approaches we can take to handle systems as they become more complex.

### Slowly Growing in Complexity

As we called out in an earlier video, a solution that's good for one problem might not be so good for a different problem. And as a system becomes more complex and grows in usage, a solution that worked well before may no longer be well-suited. Let's say you're writing a secret Santa script where each person gives a secret gift to one other randomly assigned person. The script randomly selects pairs of people and then sends an email to the gift-giver telling them who they're buying a present for. If you're doing this for the people working on your floor, you might just **store the list of names and emails in a CSV file**.  
The file will be small enough that the time spent parsing it won't be significant. Now if this script grows into a larger project that handles everyone at your company and the company keeps hiring more and more people, at some point parsing the file will start taking a lot of time. This is where you might want to consider using a different technology.

For example, you could decide to store your data in a **SQLite** file. This is a lightweight database system that lets you query the information stored in the file without needing to run a database server. Using SQLite for the data probably works just fine for assigning secret Santas at your company. But imagine that you've kept adding features to the service. So it now includes a way to create a wish list, a machine learning algorithm that suggests possible gifts and a tracker that keeps a history of each present given. And since people at your company love the program so much, you've made it an external service available to anybody. Keeping all the data in one file would be too slow. 

So you'll need to move to a different solution. You have to use a **fully-fledged database server**. Probably even running on a separate machine than the one running the secret Santa service. And there's even one more step after that. If the service becomes really really popular, you might notice that your database isn't fast enough to serve all the queries being requested. In that case, you can **add a caching service like memcached** which keeps the most commonly used results in RAM to avoid querying the database unnecessarily. So we've gone from hosting the data in a CSV file to having it in a SQLite file then moving it to a database server and finally using a dynamic casher in front of the database server to make it run even faster.

A similar progression can happen on the user facing side of the same project. Initially, we set the Santa service would simply send emails to the people on the list. That's fine if it's a small group and there's one person in charge of the script. But as the project grows more complex, you'd want to have a website for the service to let people do things like check who their assigned person is and create wish lists. Initially, this could just be running on a web server on the same machine as the data. If the website gets used a lot, you might need to add a **caching service like Varnish**. This would speed up the load of dynamically created pages. And eventually, this still might not be enough. So you need to distribute your service across many different computers and use a **load balancer to distribute the requests**. 

You could do this in-house with separate computers hosted at your company, but this means that as the application keeps growing you need to add more and more servers. It might be easier to use virtual machines running in the cloud that can be added or removed as the load sustained by the service changes.  
These examples show how important it is to find the right solution for each problem. It makes no sense to deploy a multi server web service with a distributed database for storage when you're only going to have a few dozen users. You just need to pay attention to how the service is growing to know when you need to take the next step to make it work best for the current use case. Up next, we'll talk about some of the issues that you might come across when dealing with complex systems.

### Dealing with Complex Slow Systems

In our last video, we discussed how systems that grow in usage also grow in complexity. In large complex systems, we have lots of different computers involved. Each one doing a part of the work and interacting with the others through the network. For example, think of an e-commerce site for your company.  
The **web server** is the part of the system that directly interacts with external users. Another component is the database server, which is accessed by the code that handles any requests generated from the website, and depending on how the whole system is built, you might have a bunch of other services involved doing different parts of the work. 

There could be a **billing system** that generates invoices once orders are placed.  
A **fulfillment system** used by the employees preparing the orders for customers.  
A **reporting system** that once a day creates a report of all the sales placed and possibly more.  
On top of this, you should probably have **backup, monitoring, testing infrastructure**, and so on. A system like this can be tricky to debug and understand. What do you do if your complex system is slow? As usual, what you want to do is find the bottleneck that's causing your infrastructure to underperform. Is it the generation of dynamic pages on the web server? Is it the queries to the database? Is it doing the calculations for the fulfillment process? Figuring this out can be tricky. 

So one key piece is to have a **good monitoring infrastructure** that lets you know where the system is spending the most time. Saying notice that getting the web pages is pretty slow. But when you check the web server, you see that it's not overloaded. Instead, most of the time is spent waiting on network calls, and when looking at your database server, you find that it's spending a lot of time on Disk I/O. This shows that there's a problem with how the data is being accessed in the database. One thing to look at is the indexes present in the database. When a database server needs to find data, it can do it much faster if there's an **index on the field** that you're querying for. On the flip side, if the database has too many indexes, adding or modifying entries can become really slow because all of the indexes need updating. So we need to look for a good balance of having indexes for the fields that are actually going to be used. 

If the problem is not solved by indexing and there are too many queries for the server to reply to all of them on time, you might need to look into either **caching the queries or distributing the data** to separate database servers. Now what if when you try to figure out why the service is slow, you see that the CPU on the web serving machine is saturated. The first step is to check if the code of the service can be improved using the techniques that we explained earlier. If it's a dynamic website, we might try adding caching on top of it. But if the code is fine and the cache doesn't help because the problem is that there's just too many requests coming in for one machine to answer all of them, you'll need to distribute the load across more computers. To make this possible, you might need to reorganize the code so that it's capable of running in a distributed system instead of on a single computer. 

This might take some work, but once you've done it, you can easily scale your application to as many requests as needed by adding more computers to the system, and finally, make sure that you actually need to do whatever you're doing. Lots of times, as projects evolve, we're left with a scary monster of layer after layer of complex code. If we think about what our system is doing for a few minutes, we might end up discovering that there's a whole piece that wasn't needed at all and it was making our servers do unnecessary work all along. If all of this is starting to sound too difficult and scary, don't worry. Remember that if you ever need to deal with such complex systems, one of your best tools is to ask your colleagues for help. Up next, we'll try our hand at solving a real life problem with something complex.

### Using Threads to Make Things Go Faster

Our company has an e-commerce website that includes a bunch of images of the products that are up for sale. There's a rebranding coming up, which means that all of these images will need to be replaced with new ones. This includes both the full-size images and the thumbnails. We have a script that creates the thumbnails based on the full-size images. But there's a lot of files to process, and our script is taking a long time to finish. It looks like it's time to take it up a notch and use something better to do the resizing. We'll start by trying out the current script as-is using a set of 1,000 test images. There's more images to convert, but it'll be easier to test the speed of our script with a smaller batch. We'll execute our program using the time command to see how long it takes.

It took about two seconds for 1,000 images. This doesn't seem too slow, but there's tens of thousands of images that need converting, and we want to make sure that the process is as fast as possible. Let's try making this go faster by having it process the images in parallel. We'll start by importing the **futures sub module**, which is part of the concurrent module. This gives us a very simple way of using Python threads.
To be able to run things in parallel, we'll need to create an executor. This is the process that's in charge of distributing the work among the different workers. The futures module provides a couple of different executors, one for using threads and another for using processes. We'll go with the **ThreadPoolExecutor** for now.

Now the function that does most of the work in this loop is **process_file**. Instead of calling it directly in the loop, we'll **submit a new task to the executor** with the name of the function and its parameters.
Our for loop now creates a bunch of tasks that are all scheduled in the executor. The executor will run them in **parallel using threads**. An interesting thing that happens when we use threads is that the loop will finish as soon as all tasks are scheduled. But it will still take a while until the tasks complete. So we'll add a message saying that we're waiting for all threads to finish, and then call the shutdown function on the executor. This function waits until all the workers in the pool are done, and only then shuts down the executor.

All right, we've made the change, let's save our script and test it out.
Our script now takes 1.2 seconds. That's a nice improvement over the two seconds we saw before. See how the user time is higher than the real time? By using multiple threads, our script is making use of the different processors available in the computer. And this value shows the time used on all processors combined. What do you think will happen if we try to use processes instead of threads? Let's try this out by changing the executor that we're using.
By changing the executor to the **ProcessPoolExecutor**, we tell the futures module that we want to use **processes instead of threads for the parallel operations**. Let's save and try this one out now.
Wow, this is now taking less than a second to finish, and the user time has gone up even more. This is because, by using processes, we're making even more use of the CPU. The difference is caused by the way threads and processes work in Python. **Threads use a bunch of safety features** to avoid having two threads that try to write to the same variable. And this means that when using threads, they may end up waiting for their turn to write to variables for a few milliseconds, adding up to the small difference between the two approaches.

In this video, we looked into how we can add threading support to a Python script to make better use of our processor power. There's still more improvements that we can make to our script, like checking if the thumbnail exists and is up to date before doing the conversion. Or adding a second progress bar while waiting for tasks to finish, to make it clear that our script is doing its job. We won't go into those here, but if you're interested, you can explore those possibilities on your own. Up next, another reading with pointers to more information, followed by the last practice quiz of the module.

## Module Review

Over the last few videos we've learned about the many different factors that can cause our computer to run slowly. We didn't cover absolutely every possible cause, but we did check out the most common reasons. We talked about how the first thing to do when faced with a slow system is to identify the bottleneck. To do this, you'll need to understand how each component interacts with the system and what resource is being exhausted. 

Sometimes the root cause is that the hardware isn't enough, or maybe it's just that there are too many things happening at the same time.  
Other times the problem might be in the code itself. When trying to fix a program that's slow, we should avoid code that does expensive operations.  
We went over several best practices to help us write better performing code.  
We discussed when to use the right data structures, how to avoid expensive loops, and how to keep results local, by creating a cache for example.  
We then spent some time reviewing complex systems and looked at some examples on how to troubleshoot slowness in this type of environment. 

Next time you have to debug a performance problem, you'll be able to think about what the **bottleneck** is, look for what's **exhausting** that resource, and come up with ideas for how to make things go faster. I hope you're starting to see how the skills you're picking up can really help you as you face some of these same issues at your workplace. There's no way you're going to be able to solve every issue, but hopefully you're starting to feel even more confident in your skills and abilities. Up next, we've got another lab for you to get some practice. You'll have to debug a system that's running slow and make it perform better.

# Week 3

## Why Programs Crash

Welcome back and congratulations on making it here. In the last module, we learned about a bunch of things that can make our computer, our code, or our systems run slow. We looked into the root causes and the possible remedies that might improve performance. You're sure not suffering from slowness, you've already zoomed through the first half of the course. Great job. In this module, we'll look at another area of IT that often keeps us busy. The many things that can cause programs to crash unexpectedly. If you've used computers, you've seen software crash at one time or another. A program terminates unexpectedly, a device reboots for no apparent reason, the operating system hangs and we lose all our unsaved work. In my job, I've had to deal with my fair share of crashing applications; programs that terminate with uncaught exceptions, systems that fail to update to the latest version, jobs that silently die and I'm left wondering what happened. Not long ago, I had to debug a program that was crashing every few days. This program parsed logs to generate alerts when it found suspicious events. When the task crashed, everything being processed was dropped. The task was then restarted and the log files reprocessed. So while no data was actually loss, the reoccurring crashes were increasing the average time to process the data. To fix this, I first follow the code to understand what it did. That led me to figure out the problem. The program was starting a bunch of threads but never closing them, so it eventually ran out of memory and crashed. I was then able to fix it by making sure all threads got cleaned up once they've completed their task. Generally, the cause of these crashes is that the software ran into an unexpected situation, a state that the developers didn't anticipate. Because these are unexpected situations, they can be triggered by very broad range of things. It could be a hardware problem, like a broken ramjet that causes a program to get invalid data when trying to access the memory. There could be a bug in some part of the code, which does an unsupported operation, like trying to read an element from an empty list. It could be an issue in the overall system, like if a program expects a certain library to be present or a certain directory to exist, but they don't or there could be a problem with the input provided by the user. Like if we ask the user to enter a number and they enter a string instead. The list goes on. There are a ton of things that can cause a crash. Instead of knowing all of them, we need to learn to reduce the scope of the problem so that we can get to the bottom of it. In the next few videos, we'll learn a bunch of different techniques that we can use to understand the root causes and how to fix them, or at least lessen the damage when fixing is not possible. We'll first look at how we can understand the problem. We'll then check out what we can do when we don't have access to change the program's code, and what we can do when we do have access to the source code, even if it's not our own code. Finally, we'll also look at what to do when the problem isn't just one computer crashing, but a larger incident affecting complex systems. We'll also dive into how to document a problem and it's solutions, and how to learn from our mistakes by writing postmortems. As usual, we'll put all this knowledge into action by solving real-world problems. You'll have the opportunity to try fixing a complex crashing problem by the end of the module. Let's get going.

### Systems That Crash

Got you. You should have seen the look on your face. But seriously, there are a ton of different reasons why applications crash. When we come across a program that terminates unexpectedly, we go through our usual cycle of gathering information about the crash, digging in until we find the root cause, and then applying the right fix. Say for example that a user asks for your help with a problem on their computer. When you ask for details, the user tells you that the internal billing application crashed while they were trying to generate an invoice for a customer. Now, this could be caused by lots of different things. So what you need to do is reduce the scope of the problem, and remember, you want to start with the actions that are easier and faster to check. As a first step, you tried looking at the logs to see if there's any error that may point to what's happening, but you only find an error saying application terminated and no useful information. So you check if the user can reproduce the problem by doing this same action on a different computer. You ask the user to try this out, and it turns out on a different machine that can generate the invoice just fine. So that means that the problem just has to do with the installation or configuration on that specific computer. Great news. You've already reduced the scope to something machine-specific. Another thing that you might want to check is if this happens reliably. Do all invoice generations fail? Is it confined to one specific product or customer? For this example, let's say that when you ask the user to try generating other invoices, it works just fine even for the same customer. Okay, you think maybe this problem was with a specific order for that specific customer on that specific computer. That's rather suspicious, but not so fast. The user tells you that after creating all the invoices for the day, they tried to generate a report, and the application crashed again. But then it worked the next time. You double-check with other users and find out the application isn't crashing when they use it. So what does this mean? The application seems to be crashing randomly but only on that computer. To further reduce the scope, you'll want to know if it's just that application or the whole system. To check this out, you can try moving away the local configuration for the program and using the default configuration instead, or maybe even reinstalling the application. You might also ask the user if they've seen crashes on any other application. For this example, let's say that reinstalling the application and running it with the default configuration still leads to random crashes. I'm impressed to remember, the user tells you that their web browser also crashed last week when they were using the internal webmail. At this point, the information points to a problem in the overall system, either the hardware or the OS installation. If you have a spare computer available, it might make sense to give one to the user at this point so that they can go back to work while you try to figure out the root cause of the problem. What can you do to further reduce the scope? By now, there's a high likelihood if the problem being hardware related. So one thing you could do is try taking the hard drive out of the computer and putting it into a different computer. This works best when you already have a spare case that you know works well so that you can use it for tests like these. That way you can quickly check if it's a problem with the data and the drive or the rest of the computer. Let's say that after putting the hard drive in the other computer, the applications run without unexpected crashes. This means that some hardware component is at fault. The next step is to find out which one. Given the random crashes, one thing to check would be the RAM. Memory chips deteriorate over time. When they do, the computer might write data to some part of the memory and then get a totally different value when trying to read it back. To check the health of our RAM, we can use the memtest 86 tool to look for errors. We run this tool on boot instead of the normal operating system so that it can access all of the available memory and verify if the data written to memory is the same when it tries to read it back. If the RAM is fine, you can check if the computer's overheating by looking at the sensor data provided by the OS. If that's not the case, check if there's a problem with external devices like a graphics card or sound card. You can do this by disconnecting or replacing the devices present in the computer and checking if the crashes still occur. So what can you do if when putting the hard drive in a separate computer, you still get the strange caches? This means the problem is in the drive itself or the OS installation. As with RAM, our hard drives age. At some point, the data that the computer reads stops matching what was originally stored. Each OS ships its own battery of hard drive checking tools, and you should familiarize yourself with ones in the OS you're working with. You'll want to look at the output of the tools that check the disk for bad sectors, and you'll also want to use these smart tools which can help detect errors and even try to anticipate problems before they affect the computer's performance. What can you do with the hard-drive turns out to be fine? You'd need to look into the possible OS issues, but before doing that, ask yourself, is it worth it? Looking to what's wrong with the installation can take a lot of valuable time. If the installation is easy to replicate, then just reinstalling the OS might be faster and simpler than looking into why it broke. Alright, so that's a glimpse of how you can try to diagnose a system that's unstable and behaving in weird ways. But often, you'll be dealing with a specific application that's misbehaving. In this case, it's almost certainly above in the application's code that's not taking into account a situation that, though unexpected, can sometimes occur. Up next, we'll check out what you can do when that happens.

### Understanding Crashing Applications

When an application crashes and we don't know why we'll want to look for logs that might relate to the failure. To look at logs on Linux will open the system log files and VAR log or the user log files and dot accession errors file. On Mac OS we generally use the console app to look at logs and the event Viewer on Windows. So what kind of data should you look for in these logs most logs have a date and time for each line locked knowing when the application crashed you can look for a log line around that time. And try to find an error message related to the application that crashed. Sometimes the errors will be self-explanatory like permission denied no such file or directory connection refused. Sometimes it will be a cryptic message and you have no idea what it means. Ever we have an error message no matter how weird it seems we can search for it online to try to figure out its meaning. If we're lucky, we might find the official documentation of what that error means and what we can do about it. But even if that's not available, will usually come across posts by others who have tackled a similar error and this additional information can help us understand what's going on. If there are no errors or the errors aren't useful we can try to find out more info by enabling sling debug logging. Many applications generate a lot more output when debugging logging is enabled. We might need to enable it from a setting in the applications configuration file or a command line parameter to pass when running the application manually. By enabling this extra logging information, we can get a better idea of what's actually causing the problem. And what do we need to do if there are no logs or error messages at all. In that case we need to use tools that let us see what going on inside the program. We call that a few are ready. On Linux we use S Trace to see what system calls a programs doing. The equivalent tool is called de trois on Mac OS process monitor is a Windows tool that can also take a peek inside what's going on inside a process on Windows?
By tracing which system calls a program is doing we can see what files and directories it's trying open what network connections it's trying to make and what information it's trying to read or write. This can give us a better idea of what caused the actual problem. We could find that the problem is caused by a resource not being present that the program expects to be present. Like we saw with the missing directory example in the earlier module or we could find that the program tries to interact with the graphics interface and there isn't any because it's a service running on a server. Or the program tries to open a file but the user running the software doesn't have the necessary permissions. If the application used to work fine and recently started crashing. It's useful to look into what changed in between. The first thing is to check if the issue is caused by a new version of the application itself. Maybe there's a bug in the new version that causes the crash or maybe the way that we're using the application is no longer supported. But that's not the only possible change that could trigger crashes. It could also be that a library or service used by our application changed and they no longer work well together or it could be that there was a configuration change in the overall environment. Like if the user isn't in a specific group anymore or if the files that the application used are in a different location. When trying to figure out what changed logs can also be a useful source of information. In the system log we can check which programs and libraries were recently updated checking for configuration changes might be harder depending on how you manage that configuration. If the settings are managed through a configuration management system and the values are stored in a Version Control System. Then you might be able to look at the history of changes and figure out which one triggered the failure. We call that a few times already how important it is to have a reproduction case for a problem that we're trying to solve. When we're trying to debug an application that crashes finding a reproduction case can help us both understand what's causing the crash and figure out what we can do to fix it. So it's valuable to spend some time figuring out the state that triggers the crash. This includes the overall system environment the specific application configuration the inputs to the application the outputs generated by the application the resources that uses and the services it communicates with. When trying create the reproduction case it might be useful to start from a clean slate and slowly put the pieces in place until the crash triggers. This might include trying out the application with the default configuration instead of the local one or on a freshly installed computer instead of the computer where it's crashing. And remember we want to make the reproduction case as small as possible this lets us better understand the problem and also quickly check if its present or not when we attempt to fix it. And even if we end up unable to fix the issue having a small and simple reproduction case is extremely helpful in reporting a bug to the program's developers. So to sum this up to find the root cause of a crashing application will want to look at all available logs figure out what changed trace the system or library calls the program makes and create the smallest possible reproduction case.
After doing all of this, we should have some idea of what the root cause of the issue is and maybe even how to fix it.
The strategy for fixing problems will depend on whether we can fix the code or not. In our next video, we'll check out what you can do when you can't fix the program and need to work around the issue. And in later videos, we'll deep dive into strategies for fixing faulty code.

### What to do when you can't fix the program?

One of the great things about working in IT is that we can tell the computer what to do and it will follow our orders. When dealing with unexpected behavior in the software written by other people though, we might not always be so lucky. It could be that we're dealing with proprietary software and the source code isn't available at all, or we might have access to the source code but it's written in a language that we don't understand and so we can't change it. No matter the reason, what can you do if you need to fix an application that crashes and you can't change the code. You'll need to figure out a way of working around the problem and avoiding the crash. The actual workaround will depend on what the issue is that you're trying to solve. Let's do a rundown of some of the available options. Say you figured out that the issue was caused by a specific data input that makes the application crash. The crashes only happen when the input isn't in the format the code expects. Some of your systems generate data in XML format which used to work fine with the previous version of the software but the new version now requires all data to be in a YAML format. In this case you can write a script that pre-processes the data and make sure that it's in the format that the program expects. Similarly if the problem is caused by an external service that the application uses and that's no longer compatible, we could write a service to act as a proxy and make sure that both sides see the requests and responses they expect. This type of compatibility layer is called a Wrapper. A Wrapper is a function or program that provides a compatibility layer between two functions or programs so they can work well together. Using Wrappers is a pretty common technique when the expected output and input formats don't match. So if you're faced with some sort of compatibility problem don't be afraid to write a Wrapper to work around it. Another possibility you might need to look at is if the overall system environment is it working well with the application. In this case, you might want to check what environment the applications developers recommend and then modify your systems to match that. This could be running the same version of the operating system using the same version of the dynamic libraries or interacting with the same back end services. Say the application was developed and tested on Windows 7, if you run into problems while trying to run it under Windows 10, you might want to use Windows 7 instead or if the application was developed and tested for Ubuntu and you're having trouble running it under Fedora, you might want to try running it on Ubuntu instead, and what can you do if you can't make the environment match? This could happen, for example, if there's another application that requires a different version of the same library or you can't change a certain configuration setting because it's required to access a different service. In this case, you might want to consider running the application inside a virtual machine or maybe a container. These are two different things but we won't go into details of how they are different here. All you need to know right now is they both let you run the affected application in its own environment without interfering with the rest of the system. This is what we need if we want the environment to be different than the one other Applications are using on the same computer. Sometimes we can't find a way to stop an application from crashing but we can make sure that if it crashes it starts back again. To do this, we can deploy a watchdog. This is a process that checks whether a program is running and when it's not starts the program again. To implement this, we need to write a script that stays running in the background and periodically checks if the other program is running. Whenever the check fails the watchdog will trigger the program to restart. Doing this won't avoid the crash itself. But it will at least ensure that the service is available. This works well for services where availability matters more than running continuously and no matter how you work around the issue, remember to always report the bug to the application developers. As we called out, if you have a good reproduction case for your issue, it makes it easier for the developers to figure out what's wrong and how to fix it. So when you report a bug make sure you include as much information as possible, share good reproduction case and answer the questions that we mentioned earlier on. What were you trying to do? What were the steps you followed? What did you expect to happen? What was the actual outcome? Up next, we'll see how to apply these skills to troubleshoot an application that's crashing.

### Internal Server Error

A colleague has alerted us that a webpage on our Web server isn't working. As we've done before, we need to figure out what this means exactly. We asked our colleague for more details and they told us that the failing webpage is at site.example.com/blogs. Let's check out if this is failing for us as well. There it is, the server responded with a 500 error. This error usually means that something on the server side of the application crashed, but we have no idea what. We'll need to investigate to find out more information. Let's connect to the Web server and try to figure out what's up.
The first step is looking at logs, as we called out on Linux systems, logs are located in Bar log. To do that, we'll use the date command to check the current date. Let's change into that directory and check out if there are any recent logs about our error and then the Ls -Lt command which sorts the files by the last modified date connecting it to the head command to keep the top 10 lines. We just triggered the error but there doesn't seem to be anything recent in the logs. Just in case, let's check out the last lines insists log using tail.
Nope. Nothing interesting here. We need to figure out how we can get more information, but we don't even know which web surfing software is being used on this computer. But we do know that the Web server is running on port 80, the default web serving port. How can we find which software is listening on port 80? We can use the netstat command which can give us a bunch of information about our network connections depending on the flags we pass. This command accesses a bunch of sockets that are restricted to route the administrator user on Linux. So we'll need to call it with sudo which lets us run commands as root, and then we'll pass a bunch of flags netstat. We'll use -n to print numerical addresses instead of resolving host names. L to only check out the sockets that are listening for connection, and P to print the process ID and name to which each socket belongs. Since we only care about port 80, we'll connect the output to a grep command checking for colon 80.
Great, we got new information. We see that the process listening in port 80 is called "nginx." One of the popular web serving applications out there. We now want to check out the configuration for our site. Configuration files on Linux are stored in the etc directory. So let's look at etc/nginx.
There's a bunch of files here. Lots of different configuration options that you can set in the Web server. We're looking for the configuration related to a specific site. So let's look at etc/nginx sites-enabled.
There are two files here one for the default site and one for the site.example.com site that's the one we want. Let's open it with the VI editor.
There's not a lot here, but at the bottom we see that it says uwsgi_pass, and then the local host address followed by a different port number. It seems that this website isn't being served directly from nginx, instead, the software is passing the control of the connections to uWSGI which is a common solution used to connect a Web server to programs that generate dynamic pages. So let's see if we can find the configuration for that one. We'll exit VI with a colon q and then see if there's anything interesting in etc/uwsgi. Here we only see two directories, apps-available and apps-enabled. Let's say it's an apps-enabled.
Cool. We found the uWSGI configuration for our site. Let's check it out.
Nice. This file has a lot more information. We see that the main directory for the application is srv/site.example.com that the applications run as the dub-dub-dub Data User and Group, that it's running a Python three script called prod.py that the log is stored in var/log/site.log and a bunch of other things. All right. Let's use this extra information and see if we can find out what's that. Let's exit with colon q once more and then check out that log file. Weird, the log file has a size of zero, that doesn't seem right. Let's see if we can find out anything else by looking at the Python script that's executed by uwsgi srv/site.example.com prod.py.
There's a few different webpages configured in this file. It uses bottle which is a Python module to generate dynamic web pages. At the bottom, we see the configuration for the logs page that's currently failing. Hopefully, a colleague left a comment saying that we can get debugging information by uncommenting the line that calls bottle.debug. That's exactly what we need. To uncomment this line, we need to have write access to the file though, and VI is open in read only mode currently. Let's exit an open again with sudo to be able to modify it.
Okay. We've made the change, let's save it and reload uwsgi as the instructions say. We'll do this by running sudo service uwsgi reload.
We've added debugging information. Hopefully, that will tell us why the pages failing. Let's reload the website and see what happens.
Great news, this time we see a trace back of the error and we see that the issue is that the application is getting a permission denied error when trying to open var/log/site.log. Remember that we thought it was weird that the file was empty, it seems that it's somehow broken. Let's look at it again, this time let's check if there are any other files that start with site.
So there's a site.log file and a site.log.1 file. That's pretty common when using log rotate to rotate the logs and avoid them getting too big. But there's something else afoot here. See how one file belongs to the root user and the other belongs to the dub-dub-dub data user. If you look at the permissions of the file, you might notice that they are set to allow the owner to write them and the owner and the group to read them, but the rest of the users can't access them. We saw earlier that the application is running with the dub-dub-dub data user. So if site.log belongs to the root user, the application won't be able to either read or write to this log file. Ding-ding-ding seems like we found the root cause of our issue. Let's change the owner of the site.log file to fix the immediate problem.
Let's try reloading our page now.
Yes, it works. The log is empty now because the application have not been able to write to it. But if we keep reloading, we'll see how it populates with our entries.
All right. We've fixed the immediate problem our Web pages working once again, but we still need to take care of the long-term remediation. Why was the ownership of the file wrong? We suspect that there might be something wrong with the log rotate configuration but we'd need to keep looking to find out what's up with that. In this video, we looked into how we can figure out what's up with an application that's failing. We checked out a bunch of different tools and ideas that can help us understand what's going on and get more information until we can find the root cause. I hope we're starting to see how these lessons provide valuable tools for diagnosing and solving issues that will for sure occur at your job. Up next, we have a reading with some links to learn more about different things that can make your computer crash, then a quick practice quiz.

## Code that Crashes

### Accessing Invalid Memory

In our earlier videos, we looked into a bunch of different things that can make software crash and what we can do about them when we can't fix the code. If we're able to make the application behave correctly though, we'll have a lot more options for dealing with the crash. Of course to apply these fixes, we'll need to understand why the crash is even happening. One common reason a program crashes is it's trying to access invalid memory. To understand what this means, let's quickly explain how using the memory works on modern operating systems. Each process running on our computer asks the operating system for a chunk of memory. This is the memory used to store values and do operations on them during the program's execution. The OS keeps a mapping table of which process is assigned which portion of the memory. Processes aren't allowed to read or write outside of the portions of memory they were assigned. So accessing invalid memory means that the process tried to access a portion of the system's memory that wasn't assigned to it. Now, how does this even happen? During normal working conditions, applications will request a portion of the memory and then use the space at the OS assigned to them. But programming errors might lead to a process trying to read or write to a memory address outside of the valid range. When this happens, the OS will raise an error like segmentation fault or general protection fault. What kind of programming error is this? It typically happens with low-level languages like C or C++ where the programmer needs to take care of requesting the memory that the program is going to use and then giving that memory back once it's not needed anymore. In these languages, the variables that store memory addresses are called pointers. They're just like any other variable and code that can be modified as needed. So if a pointer is set to a value outside of the valid memory range for that process, it will point to invalid memory. If the code then tries to access the memory the pointer points to, the application will crash. Common programming errors that lead to segmentation faults or segfaults include forgetting to initialize a variable, trying to access a list element outside of the valid range, trying to use a portion of memory after having given it back, and trying to write more data than the requested portion of memory can hold. So what can you do if you have a program that's said vaulting? The best way to understand what's going on is to attach a debugger to the faulty program. This way when the program crashes, you'll get information about the function where the fault happened. You'll know the parameters that the function received and find out the address that was invalid. That might already be enough to understand the problem. Maybe a certain variable is being initialized to late or the code is trying to read too many items on a list. If that's not enough, the debugger can give you a lot more detail on what the application is doing and why the memories invalid. For this to be possible, we'll need our program to be compiled with debugging symbols. This means that on top of the information that the computer uses to execute the program, the executable binary needs to include extra information needed for debugging, like the names of the variables and functions being used. These symbols are usually stripped away from the binaries that we run to make them smaller. So we'll need to either recompile the binary to include the symbols, or download the debugging symbols from the provider of the software if they're available. Linux distributions like Debian or Ubuntu ships separate packages with the debugging symbols for all the packages in the distribution. So to debug and application that's segfaulting, we download the debugging symbols for that application. Attach a debugger to it, and see where the fault occurs. When doing this, we might find that the crash happens inside a call to a library function. This is separate from the application itself, so we need to install the debugging symbols for that library. We might need to repeat this cycle a few times before we can identify the portion of the code that's buggy. Microsoft compilers can also generate debugging symbols in a separate PDB file. Some Windows software providers let users download the PDP files that correspond to their binaries to let them properly debug failures. One of the trickiest things about this invalid memory business is that we're usually dealing with undefined behavior. This means that the code is doing something that's not valid in the programming language. The actual outcome will depend on the compiler used, how the operating system assigns memory to processes, and even the version of the libraries in use. A program that runs fine on a computer running Windows trigger a segfault on a computer running Linux and vice versa. When trying to understand problems related to handling invalid memory, valgrind can help us a lot. Valgrind is a very powerful tool that can tell us if the code is doing any invalid operations no matter if it crashes are not. Valgrind lets us know if the code is accessing variables before initializing them. If the code is failing to free some of the memory requested, if the pointers are pointing to an invalid memory address, and a ton more things. Valgrind is available on Linux and Mac OS, and Dr. Memory is a similar tool that can be used on both Windows and Linux. So all of that said, what do we do when we finally discover the cause of the segfaults? You'll want to either change the code yourself or get the developers to fix the problem in the next version. This might sound scary if you've never programmed in the language used by the application. But when you know what's wrong with the code, it's usually not that hard to figure out how to fix it. If a variable is initialized too late, fixing the problem can be as easy as moving the initialization to the right part of the code, or if a loop is accessing an item outside of the length of the list, you might solve the issue by checking that there aren't more iterations than needed. Throughout this program, we've been teaching you these concepts so you can apply them to any piece of code no matter which language the program is using. So don't be afraid to put this into practice. You've got the skills for it. If the program is part of an open source project, you might find that someone else has already done the work, and so you can apply a patch available online. If there's no patch and you can't say you're the bug out yourself, you can always get in touch with the developers and ask a fake and fix the issue and create the necessary patch. In high-level languages like Python, the interpreter will almost certainly catch these problems itself. It will then throw an exception instead of letting the invalid memory access reach the operating system. But still those exceptions can be pretty annoying. We'll talk about those in our next video.

### Unhandled Errors and Exceptions

In our last video, we talked a lot about what happens when a program tries to access invalid memory. Correctly handling memory is a hard problem, and that's why there's a bunch of different programming languages like Python, Java, or Ruby that do it for us. But that doesn't mean programs written in these languages can't trigger weird problems. In these languages, when a program comes across an unexpected condition that isn't correctly handled in the code, it will trigger errors or exceptions. In Python, for example, we could get an index error if we tried to access an element after the end of a list. We might get a type error or an attribute error if we try to take an action on a variable that wasn't properly initialized or division by zero error if we tried to well, divide by zero. When the code generates one of these errors without handling it properly, the program will finish unexpectedly. In general, unhandled errors happen because the codes making wrong assumptions maybe the program's trying to access a resource that's not present or the code assumes that the user will enter a value but the user entered and empty string instead. Or maybe the application is trying to convert a value from one format to another and the value doesn't match the initial expectations. When these failures happen, the interpreter that's running the program will print the type of error, the line that caused the failure, and the traceback. The traceback shows the lines of the different functions that were being executed when the problem happened. In lots of cases, the error message and traceback info already gives us enough to understand what's going on, and we can move on to solving the problem. But sadly, that's not always the case. The fact that a piece of code crashes on one function doesn't mean that the error is necessarily in that function. It's possible, for example, that the problem was caused by a function called earlier which set a variable to a bad value. So the function where the code crashes is just accessing that variable. So when the error message isn't enough, we'll need to debug the code to find out where things are going wrong. For that, we can use the debugging tools available for the application's language. For a Python, program we can use the BDB interactive debugger which lets us do all the typical debugging actions like executing lines of code one-by-one or looking at how the variables change values. When we're trying to understand what's up with a misbehaving function on top of using debuggers, it's common practice to add statements that print data related to the codes execution. Statements like these could show the contents of variables, the return values of functions or metadata like the length of a list or size of a file. This technique is called print f debugging. The name comes from the print f function used to print messages to the screen in the C programming language. But we can use this technique in all languages, no matter if we use print, puts, or echo to display the text on the screen. Let's take this one step further. When changing code to print messages to the screen, the best approach is to add the messages in a way that can be easily enabled or disabled depending on whether we want the debug info or not. In Python, we can do this using the logging module. This module, lets us set how comprehensive we want our code to be. We can say whether we want to include all debug messages, or only info warning or error messages. Then when printing the message, we specify what type of message we're printing. That way, we can change the debug level with a flag or configuration setting. So you figured out why the unexpected exception was thrown, what do you do next? The solution might be fixing the programming error like making sure variables are initialized before they're used or that the code doesn't try to access elements after the end of a list. Or it could be that certain use cases that hadn't been considered needs to be added to the code. In general, you'll want to make the program more resilient to failures. Instead of crashing unexpectedly, you want the program to inform the user of the problem and tell them what they need to do. For example, say you have an application that crashes with a permission denied error. Rather than the program finishing unexpectedly, you'll want to modify the code to catch that error and tell the user what the permission problem is so they can fix it. For example, unable to write new files and temp, make sure your user has bright permissions on temp. In some cases, it doesn't make sense for our program to even run if certain conditions aren't met. In that case, it's okay for the program to finish when the error is triggered. But again, it should do so in a way that tells the user what to do to fix the problem. For example, if it's critical for an application to connect to a database but the database server isn't responding, it makes sense for the application to finish with an error saying unable to connect to the database server. It also makes sense to include all details of the attempted connection like the host name, the port, or the username used to connect. So to recap, if your program is crashing with an unhandled error, you want to first do some debugging to figure out what's causing the issue. Once you figured it out, you want to make sure that you fix any programming errors and that you catch any conditions that may trigger an error. This way, you can make sure the program doesn't crash and leave your users frustrated. Up next, we'll talk a bit about what you can do when you're trying to fix someone else's code.

### Fixing Someone Else's Code

In our IT jobs, it's pretty common to have to fix problems and code that we didn't write ourselves. It might be because we're working with a program that's open-source or with a program that was developed by someone else inside the company. When this happens, we need to spend some time getting acquainted with the code so that we can understand what's going on. Let's do a rundown of some things that can help us with that. If the code has comments and the functions are well-documented, reading these is a great place to start when trying to figure out what's going on. Remember way back in the course when we first introduced Python, we talked about the importance of developing good habits when we're writing code. Writing good comments is one of those good habits that pays off when trying to understand code written by others and also your past self. Unfortunately, a lot of code doesn't include enough comments, leaving us to try to understand it without enough context. If that's the case, you can improve things by adding comments as you read the code and figure out what it's doing. Writing these comments help you solidify your understanding. If you contribute those comments back to the original developers, you can help anybody else trying to understand the code. Another thing that can help to understand someone else's code is reading the tests associated to the code. Well-written tests can tell us what each function is expected to do. Looking at the existing tests can show us which use cases weren't taken into account. But what if there aren't enough tests? Just like with writing extra comments, writing some tests of your own can help you better see what the code is supposed to do and improve overall quality of the code. This can also be really useful when modifying the original code. To ensure that changes you make, don't break the rest of the functionality. In my job, I need to make changes to code written by other people a lot. I definitely read the comments and sometimes reference the tests too. But in the end, to really understand what's going on, I just have to read through the code. But how do you even start reading through someone else's code? This depends a bit on personal preference and the size of the project. If there are only a couple of 100 lines of code, it's feasible to read all of them. But when the project has thousands or tens of thousands of lines of code, you can't really read the whole thing. You'll need to focus on the functions or modules that are part of the problem that you're trying to fix. One possible approach in this case, would be to start with the function where the error happened, then the function or functions that call it, and so on until you can grasp the contexts that led to the problem. While this is of course much easier if it's in a programming language that you're familiar with, you don't need to be an expert in the language to fix a bug in the program. If you've come across an error and debug the issue well enough to understand what's going on, you might be able to fix the problem even if you've never seen that language before. This is one of those skills that gets better with practice. So it might make sense to you to start practicing before you need to fix a problem in the code. Take a program that you both use and have access to its code and figure out how it does a specific action. Follow the code until you really understand what's going on. For example, you could take the web server software you're using and check out how it parses its configuration files, or take a look at one Python module you like, like Python Request for example, and figure out how it processes the data it receives. Doing this, you can get used to reading code written by others and understanding what it's doing. Another option is to pick an open-source project that you use. Look at the list of open issues and to have a go at fixing an easy one. To do that, you'll need to find your way around the code, understand what it's doing and what to change. By practicing doing this, you'll improve your ability to quickly figure out what the code does and what needs to be changed, while helping improve the project's overall quality. Up next, we'll get some practice fixing issues and a couple of different programs that crash.

### Debugging a Segmentation Fault

Over the past videos, we've discussed a bunch of different types of crashes. Let's now check out what a segmentation fault looks like in action. We have a simple example program that crashes with a seg fault.
When an application crashes like this, it's useful to have a core file of the crash. Core files store all the information related to the crash so that we or someone else can debug what's going on. It's like taking a snapshot of the crash when it happens to analyze it later. We need to tell the OS that we want to generate those core files. We do that by running the ulimit command, then using the -c flat for core files, and then saying unlimited to state that we want core files of any size. Once we've done that, we can try executing our example again.
All right, our crashing program has generated a core file. Let's check it out using LS-L.
This file contains all the information of what was going on with the program when it crashed. We can use it to understand why the program crashed by passing it to the GDB debugger. We'll call it gdb-c core to give it a core file and then example to tell it where the executable that crashed is located.
When it starts, GDB shows a bunch of messages including its version, license, and how to get help. It then tells us that the program finished with a segmentation fault. It shows that the crash happened inside the strlen function in a file that's part of the system libraries. The no such file or directory error that we're seeing here means that we don't have the debugging symbols for that system library, but that's okay. We trust the strlen function to work correctly. It's our code that's buggy. Let's look at the full backtrace of the crash by using the backtrace command.
The first element in the list is the function where the crash occurred. The second element is the function that called the function and so on. In this case, we see that the strlen function that failed was called by the copy parameters function in our code which was called by the main function. We can use the up command to move to the calling function in the backtrace and check out the line and copy parameters that caused the crash. We see that the faulty line is calling the strlen function, but it's not clear why that would fail. We can get more contexts for the code that failed by calling the list command that shows the lines around the current one.
Here, we see a chunk of C code. If this is the first time you look at C code, it might seem a bit confusing. That's okay. There are some similarities with Python, but also, some things that are pretty different. We see that the faulty line, line 10, is in the body of a for loop. The variable that the for loop uses to iterate is called i. Let's check out the value of i using the print command.
GDB uses the dollar sign followed by a number to give separate identifiers to each result it prints. In this case, the result is one. In other words, when the crash happened, I had the value of one. Since this variable is being used to access an array called argv, let's print the contents of the first element argv 0, and then the second element argv 1.
What are those weird numbers starting with 0x? Those are hexadecimal numbers, and they are used to show addresses in memory where some data is stored. Here, GDB is telling us that the first element in the argv array is a pointer pointing to the./example string. The second element is a pointer to zero also known as a null pointer. Zero is never a valid pointer. It usually signals the end of data structures in C. So our code is trying to access the second element in the array, but the array only has one valid element. In other words, the for loop is doing one iteration to many. This is known as an off-by-one error, and it's a super common error. In this case, the fix is really simple. We need to change the less than or equal sign to be a strictly less than sign so that the iteration stops one element before. In this video, we've got a sneak peek at what it's like debugging C applications that crashed with a segmentation fault. Up next, we'll talk about how we can debug Python applications that crash with an exception.

### Debugging a Python Crash

In our last video, we looked into an application that was crashing with a segmentation fault. That kind of problem is common when dealing with applications written in languages like C or C++. On the flip side, when using languages like Python, we usually need to deal with unexpected exceptions making our program crash. Let's look at one example of that. We have a script that updates the descriptions of some products in our company's database. It's a pretty simple script that takes a CSV file as a parameter, which includes the data that needs to be imported using the product code and description. Our script simply reads through a file and then updates the database. Most of the time it works just fine. But when the file with the new descriptions is generated by one specific user, the program fails with an exception. The user has sent us a file that's failing so that we can try to figure out what's going on. Let's first check out the contents of the file.
Okay, this seems harmless enough. Let's try executing the program.
The program failed with an exception. Let's have a look at this trace back to understand it a bit better. At the bottom, we see the name of the exception. In this case, Key Error and the message in this case, product code, which is the name of the key that's failing. Above that, we see a list of function calls with two lines per function. The first line tells us the Python file that contains the function, the line number, and the name of the function. The second line shows us the contents of that line. This information is similar to the back-trace that we saw in our last video. But the order of the functions is reversed. The function at the bottom, update data, is the one where the exception occurred. Above it, we see that update data was called by main, and on top of that we see that main was called by the line at the module level. So what's going on here? The update data function is trying to access the product code fields in a variable named row. But for some reason this is failing with a Key Error. Frequently, knowing the exception message and the line where the exception happened, is already enough to understand what's going on. But in some cases like this one, that's not enough. It's time to try our hand at using a Python debugger. We'll start the debugger by running pdb3 and then passing the script that we want to run and any parameters that our script needs. In our case, we'll call pdb3 update products.py new products.csv. When we start the debugger it gets positioned at the first line of our script and waits for us to tell it what to do. We could run each of the instructions in the file one by one using the next command. But there's a lot going on here. So we need to go through a lot of lines until we reach the failure. Alternatively, we can tell the debugger to continue the execution until it either finishes or crashes. Let's do that now.
So the program failed in the same way we'd seen before. But now we can use the debugger to get a better idea of why we're getting this pesky key error. Let's print the contents of row.
That's really weird. What are those characters appearing before product code? If we search online for the sequence of characters, will find that they represent the Byte Order Mark or BOM which is used in UTF-16 to tell the difference between a file stored using Little-endian and Big-endian. Our file is in UTF-8 so it doesn't need the BOM. But some programs still include it and this is tripping up our script. So what can we do? Fortunately, others have already faced the same issue and figured out a solution. There is a special value called UTF-8-sig that we can set as the encoding parameter of the open function. Setting this encoding means that Python will get rid of the BOM when files include it and behave as usual when they don't. Let's change the code of our script to use that encoding instead of the default. We'll look for the place where it's opening the file, then add the encoding parameter with UTF-8-sig as the value.
All right. We've made the change. Will they work now? Let's check it out.
Yeah. We've fixed the problem. Our script can now work with users generating files with and without the Byte Order Mark. In the last two videos, we looked briefly at GDB and PDB. We've barely discussed the surface of the many operations that we can do with debuggers. There are ton more advanced debugging features. Like setting breakpoints the letter code run until certain line of code is executed or watch points that letter code run until a variable or expression changes. We can also step through the code instruction by instruction to check when a problem happens and much more. We won't look into any of these advanced techniques here. But as usual, we'll put more information about this in the next reading in case you want to learn more. After that, there's another practice quiz to check out to make sure all of this has made sense.

### Resources for Debugging Crashes

Check out the following links for more information:

https://realpython.com/python-concurrency/
https://hackernoon.com/threaded-asynchronous-magic-and-how-to-wield-it-bba9ed602c32
https://stackoverflow.com/questions/33047452/definitive-list-of-common-reasons-for-segmentation-faults
https://sites.google.com/a/case.edu/hpcc/home/important-notes-for-new-users/debugging-segmentation-faults

Readable Python code on GitHub:

https://github.com/fogleman/Minecraft
https://github.com/cherrypy/cherrypy
https://github.com/pallets/flask
https://github.com/tornadoweb/tornado
https://github.com/gleitz/howdoi
https://github.com/bottlepy/bottle/blob/master/bottle.py
https://github.com/sqlalchemy/sqlalchemy

## Handling Bigger Incidents

### Crashes in Complex Systems

Up to now we've talked about how to diagnose and fix errors that are confined to one computer. That's a common case for computers that are used by a single user. But once we start going into complex systems that involve many different services, we'll need to take a look at the bigger picture and have different computers interact with each other. Say you're in charge of the e-commerce site for your company. The page as seen by the users recently started responding with internal server error to about 20% of all requests. How do you figure out what's going on? You want to apply the same principles that we saw for troubleshooting a problem on one computer, but this time at a larger scale. So you'll want to check the log messages in the servers providing the service, and see if you find any additional information pointing to what's causing the issue. You'll want to find any log specific to the service that's failing, and also look at the general system logs to see if there's a problem affecting the server in general. For this example, let's say you find a bunch of entries in the logs that say, invalid response from server. That's not a great error message. You don't know what the request was or what the response was, but it's at least a clue that whatever's happening is related to some other service in the overall system. We said that this started failing recently, so it might make sense to figure out what changed between what it was working correctly and when it started to fail. Was there a new version of the system deployed? Were there any relevant changes regarding the requests? Let's say this is happening on a Tuesday morning, and the latest release of this service was the previous week. Things were working fine until today, and the requests seemed normal, nothing out of the ordinary. So the service itself is probably okay, but what about the other services involved in the system? Was there a new version of one of the underlying systems, like the database, the authentication service, or some other back-end server like the inventory, billing, or procurement systems? Looking at recent changes, you see that there were a bunch of changes made earlier in the day to the load balancer used between the front-end and the back-end services. Since the only clue you have is that the response from the service was invalid, you're not sure that these changes are at fault, but they sure seem suspicious. Whenever possible, the best strategy is to roll back the changes that you suspect are causing the issue, even if you aren't 100% sure if this is the actual cause. If your infrastructure allows easy rollbacks, try that before doing any further investigation. Why? Because that way, you'll restore the service back to health if it was the cause, or you'll eliminate this change as a possible cause if doing the rollback doesn't help. Whether you do the rollback or not, when coming across unhelpful error messages, it's a good idea to improve them. Instead of the error just saying that the response is invalid, change it to include what the request and the response were, and why the response was invalid. That way, the next time you're trying to debug a similar issue you already have more information to work with. For this example, if the error had included this information you'd have seen that the invalid response was a 404 error. This was caused by having a server added to the pool as part of the inventory system, but the server actually belonged to the procurement system. Now, say a couple of weeks later you see that again, there are a bunch of internal server errors in the same service. It might be tempting to assume that it's the load balancer's fault once again, but by now you know that you should always look at the logs first and see what you find. There's no reason why the error should be the same this time. When looking at the logs you may notice, for example, that only one of the front-end servers is actually affected by the problem. All the other machines are serving their content successfully. In a case like this, you'd start by first removing the machine from the pool of servers that can provide this service. That way, you avoid users getting any more errors. Well, you can investigate what's going on with the broken machine. As you've probably realized by now, when dealing with complex systems like these having good logs is essential to understanding what's going on. On top of that, you'll want to have good monitoring of what the service is doing and use version control for all changes so that you can quickly check what's changed and roll back when needed. It's also important that you can very quickly deploy new machines when necessary. This could be achieved by either keeping standby servers, in case you need to use them, or by having a tested pipeline that allows you to deploy new servers on demand.
A lot of companies today have automated processes for deploying services to virtual machines running in the cloud. This can take a bit of time to set up, but once you've done that you can very easily increase or reduce the amount of servers you're using. This can help a lot when investigating and solving problems. But one thing to take into account when the servers are running as virtual machines, especially if they're running in the cloud, is that there might be external limits apply to these services. Resources, like the available CPU time, RAM, or network bandwidth, might be artificially capped. And not only that, the use of certain external services can also be limited, like how many database connections you can have at the same time or how much data you can store. If these limits are causing problems with your application, you might need to rethink how you use your resources.
We've covered a bunch of techniques that you can use when facing a problem in a complex system. Looking at the available logs, figuring out what changed since the system was last working, rolling back to a previous state, removing faulty servers from the pool, or deploying new servers on demand. Up next, we'll explore a different part of dealing with bigger incidents, communication and documentation.

### Communication and Documentation During Incidents

Until now, we've discussed how we can troubleshoot computers or systems with a specific issue. We've covered how we can get enough information so we can identify the root cause, and then apply the necessary remediation. There's another aspect to all of this. What is related to how we handle the communication with those affected by the issue and how we distribute tasks when addressing large issues as a team. Armed with what you've learned so far and your past experience, you might do a great job troubleshooting a problem. But if you drop the ball when it comes to communicating what you're doing, you could end up with a bunch of frustrated users calling you to find out what's going on. If you don't write down what you've tried or how you fix the problem, you risk for getting some important details and wasting a lot of valuable time when you need to revisit an issue. When working on a problem, it's always a good idea to document what you're doing in a bug or ticket. If there's no such system at your company, then use a doc, a text file, or Wiki, or whatever you have access to. Documenting what you do, lets you keep track of what you've tried and what the results were. This might seem unnecessary. But after a whole day of troubleshooting a problem, it's pretty common for us to forget what we've tried or what was the outcome of a specific action. On top of that, having all this info available in some electronic forum lets you easily share all the data you've collected with other team members. If for example, you brought something back which turned out to be unrelated. Having the whole process document it, helps you remember to roll forward again. While you're working on a problem, it's important to communicate clearly with those affected by the issue. They want to know what you figured out about the problem, what the available workarounds are, and when they can expect the next update. If you don't know what the problem is, it's hard to give an estimation of when you'll have it fixed. But you can still provide timely updates about the work you're doing. This kind of regular communication is helpful no matter the size of the incident. But the more people affected, the more you'll want to provide regular updates with clear instructions of what users can do and what they can expect as a solution. That way, they can better plan and organize their time. If access to the Internet is down, you want to let people know if they can expect to fix in one or two hours or if it's going to take the whole day. This info can make a difference between people choosing to discuss issues in person for a couple of hours or deciding to work from home. If the issue is big enough that you're involving more people in finding a solution, you should agree on who's going to work on which tasks. For example, you could have someone working on finding out a temporary workaround, while someone else is in charge of understanding the root cause of the problem and finding the long-term remediation. Or if there are lots of possible causes for the issue, you could divide the causes among the team members and have them work on those in parallel. On top of people looking for the root cause and a solution, you want to have a person in charge of communicating with the people affected. This lets the team avoid forgetting to update the tracking issue or even worse providing contradictory information. This communications lead needs to know what's going on and provide timely updates on the current state and how long until the problem's resolved. They can act as a shield for questions from users letting the rest of the team focus on the actual problem. Similarly, there should be one person in charge of delegating the different tasks to the team members. This person sometimes called the Incident Commander or Incident Controller needs to look at the big picture and decide what's the best use of the available resources. They can make sure that there's no duplication of work among team members and that only one person is modifying the production system at a time. Having multiple people make overlapping changes to the system could lead to confusing results, making the outage even longer. Of course, this division of roles makes the most sense when there's a large incident and there's a big team working on figuring out the solution. If it's only two or three people working on the problem, it's still important to agree who will work on what but you probably don't need to use any special role names to do that. Once the issue has been resolved, it's super-important to sum up the information that was helpful. The most important information that you'll want to include are the root cause, how you diagnose the problem and found that root cause, what you did to fix the issue and what needs to be done to prevent the problem from happening again. Depending on the size of the issue and the number of people affected, this summary could just be the last update to the bug or ticket that you use to keep track of your work, or it could be a full postmortem. What's a postmortem, and how do you write when you ask? Well, that's coming up in our next video.

### Writing Effective Postmortems

In our last video, we talked about the importance of communication and documentation when troubleshooting incidence. We called out that if the issue is big enough, we might want to document what happened in a postmortem. Postmortems are documents that describe details of incidence to help us learn from our mistakes. When writing a postmortem, the goal isn't to blame whoever caused the incident, but to learn from what happened to prevent the same issue from happening again. To do this, we usually document what happened, why it happened, how it was diagnosed, how it was fixed, and finally figure out what we can do to avoid the same event happening in the future. Remember the main goal is to learn from our mistakes. Writing a postmortem isn't about getting someone fired but about making sure that next time we do better. Writing postmortems after dealing with incidence is important because it helps us avoid dealing with them again or at least learn how to deal with the next incident better. While Postmortems are super useful with large incidence, you don't need to wait until something huge happens to write your first postmortem. You can practice riding them for any kind of event where there's something to be learned no matter how small. That way, when you need to write a postmortem after a big incident, you know how to concentrate on the things that matter the most. What you can learn from the problem and how you can prevent it in the future. So what should you write in a postmortem? The exact structure might vary depending on preference and the type of incident that you're dealing with. In general, you'll want to include the details of what caused the issue, what the impact of the issue was, how it got diagnosed, the short-term remediation you applied, and the long-term remediation you recommend. If the document is long and you're going to share it with a lot of people, you want to include a summary that highlights the root cause, the impact, and what needs to be done to prevent the issue from happening again. It's useful to include what went well in postmortems too. When working on a problem, we might realize that it would have been much worse if we didn't have certain tools or systems available. For example, we might say that we were able to solve the problem quickly by doing a roll back to the previous version or that we caught the issue before users even noticed it because we had good monitoring and alerting. Noting the things that went well helps us show that our systems are effective and justifies keeping those systems running. Writing a postmortem can sometimes help you understand the services that you're working with much better. Earlier this year, a service I worked on had a large outage and I needed to provide information on what happened. To do this, I needed to parse through hundreds of gigabytes of archive logged data to show that certain data had never been received by the service. Doing this, I realized that I needed to improve the data logged by our tools to give better information and have better reporting. You can even practice writing postmortems outside of the IT context. Like, if you bake cookies and they don't turn out as great as you wanted them to, document what you did, what went wrong, what went right, and how you can improve the results in the future. You can do this with any hobby that you have. Maybe photography, 3D printing or brewing your own beer. You don't always need to write the whole thing down. Sometimes a mental note is enough, like if you bike to work and realize wearing your backpack hurts your shoulders, make a mental note to add a basket to your bike. So you can put your backpack there next time, or if on your last trip it was colder than expected and you forgot to bring a jacket, make a mental note that next time you should check the weather before you leave. Once again, remember that the most important part of the postmortem is what we can learn for the future. So if instead of writing a whole document you're creating a one paragraph summary of the incident. Remember to focus that paragraph on what you can do better, not on whatever mistake caused the incident. Up next, we've got a quick quiz to check that everything still make sense.

## Module Review

Congratulations on making it all the way here. You've learned a lot about all kinds of crashes, errors, and incidents over the past videos. We've covered examples of what you can do to work around a problem and you don't have access to the code. We've looked at ways to solve the issues when you do have access to the code, and checked out how to deal with larger incidents that involve complex systems and large teams of people. Learning about the different ways computers and software can fail can seem scary at first. But remember that all of these tools help us get better at coming up with solutions. One of the things I love most about IT is that there are so many different ways to accomplish any task. So if you get stuck, you can always try a new angle. There's nothing like the feeling of solving a tricky problem. Throughout our examples, we've been applying the same techniques that we learned the beginning of the course. We gathered information until we understood the problem. We found the root cause and then worked on the short-term and the long-term remediation. By now, you have a better idea of what you can do when an application crashes unexpectedly, how to use elimination to figure out what's wrong, and what kind of solutions you can apply depending on the failure. Coming up, we've got some problems for you to solve. One where a program is crashing and you can't change the code, and when were you can't change the code. This might sound tricky. But remember you can always review the available material to help you figure out what's going on. Good luck, and you've got this.

# Week 4

## Managing Computer Resources

Welcome back. We're almost to the end of the course. Congratulations on making it all the way here. I hope you're starting to see just how practical these lessons are in a real-world IT environment, and that you're feeling empowered by your new troubleshooting skills. In past modules, you've learned how to troubleshoot and debug a bunch of situations. We saw how reducing scope and isolating problems can lead us to the root cause of programs that are running slowly or crushing unexpectedly. We also learned how to understand different error messages and use the tools available in the OS to diagnose what's going on. Sometimes the problem we face isn't that something doesn't work, but that it doesn't work as well as it should. Usually, this comes down to not making the best use of the available resources in the system. If our program uses too much memory for example, we might be able to work around it by adding more RAM to the computer. But wouldn't it be better if it didn't use that much memory in the first place? All resources in our computer are limited. So we need to make sure that the applications we run make the best use of them. We need to check that the software we run doesn't waste memory for things that aren't needed, or that the space on our disks is actually used by data that matters, or that the information transmitted over the network is actually the info we care about. There's always something to declutter. In the next few videos, we'll explore how we can figure out what's going on with programs that exhaust resources on our computer. Whether that's memory, disk, or even network link. Then will talk about managing our most valuable resource of all, time. We'll learn how we can look at the never-ending list of tasks that needs to be done, and make sure that we're spending our time wisely by prioritizing our work and avoiding unnecessary interruptions. After that, we'll discuss how we can apply all our new knowledge to try to avoid future problems. Being proactive could help us mitigate issues when things don't go according to plan. Hint, they rarely do, and even if would problems altogether by catching them in the test infrastructure. Finally, you'll have another opportunity to try your hand at solving a real world challenge, to put your skills into practice. Ready to get started? All right. Let's do it.

### Memory Leaks and How to Prevent Them

Most applications need to store data in memory to run successfully. We called that earlier, how processes interact with the OS to request chunks of memory, and then release them when they're no longer needed. When writing programs in languages like C, or C plus plus, the programmer is in charge of deciding how much memory to request, and when to give it back. Since we're human, we might sometimes forget to free memory that isn't in use anymore, this is what we call a Memory leak. A memory leak, happens when a chunk of memory that's no longer needed is not released. If the memory leak is small, we might not even notice it, and it probably won't cause any problems. But, when the memory that's leaked becomes larger and larger over time, it can cause the whole system to start misbehaving, not cool memory leak, not cool. When a program uses a lot of RAM, other programs will need to be swapped out and everything will run slowly. If the program uses all of the available memory, then no processes will be able to request more memory, and things will start failing in weird ways. When this happens, the OS might terminate processes to free up some of the memory, causing unrelated programs to crash. You might be thinking why should I care if I don't plan to code in C or C plus plus, it's true, the languages like Python, Java, or Go manage memory for us, but things can still go wrong if we don't use the memory correctly. To understand how this works, let's look into what these languages do. First, they request the necessary memory when we create variables, and then they run a tool called Garbage collector, that's in charge of freeing the memory that's no longer in use. To detect when that's the case, the garbage collector looks at the variables in use and the memory assigned to them and then checks if there any portions of the memory that aren't being referenced by any variables. Say for example, you create a dictionary inside a function, use it to process a text file, calculate the frequency of the words in the file, and then return the word that was used the most frequently. When the function returns, the dictionary is not referenced anymore. So the garbage collector can detect this and give back the unused memory, but if the function returns the whole dictionary, then it's still in use, and the memory won't be given back until that stops being the case. When our code keeps variables pointing to the data in memory, like a variable in the code itself, or an element in a list or a dictionary, the garbage collector won't release that memory. In other words, even when the language takes care of requesting and releasing the memory for us, we could still see the same effects of a memory leak. If that memory keeps growing, the code could cause the computer to run out of memory, just like a memory leak would. The OS will normally released any memory assigned to a process once the process finishes. So memory leaks are less of an issue for programs that are short lived, but can become especially problematic for processes that keep running in the background. Even worse than these, are memory leaks caused by a device driver, or the OS itself. In these cases, only a full restart of the system releases the memory. Say you notice that your computer seems to run out of memory a lot, you look at the running programs over the course of some time, and realize that there's a process that keeps using more and more memory as the hours pass. If you reset that process, it begins with a very small amount of memory, but quickly requires more and more. If that's the case, it's pretty likely that this program has a memory leak. So let's jog its memory, what can we do if we suspect a program has a memory leak? We can use a memory profiler to figure out how the memory is being used. As what debuggers will have to use the right profiler for the language of the application. For profiling C and C plus plus programs, we'll use Valgrind which we mentioned in an earlier video. For profiling a Python, there are bunch of different tools that are disposal, depending on what exactly we want to profile. We can be as detailed as profiling the memory usage of a single function, or as big picture as monitoring the total memory consumption over time. Using profilers, we can see what structures are using the most memory at one in time or take snapshots at different points in time and compare them. The goal of these tools is to help us identify which information we're keeping in memory that we don't actually need. It's important that we measure the use of memory first before we try to change anything, otherwise we might be optimizing the wrong piece of code. Sometimes we need to keep data in memory, and that's fine, but you want to make sure that you're only keeping the data that you actually need, and that you've let go of anything you won't be using, that way the garbage collector can give that memory back to the OS. Of course, if you check that you're using the memory correctly, but still find that your exhausting available RAM, it might be time for an upgrade. Did you commit all that to memory? Don't forget, there's a lot more to say about memory profiling than we have time to cover it, but we've included links to more information about some of these profiling tools in the next reading. Up next, we'll talk about a different resource that might need some special care, disk space.

### Managing Disk Space

Another resource that might need our attention is the disk usage of our computer. Programs may need disk space for lots of different reasons. Installed binaries and libraries, data stored by the applications, cached information, logs, temporary files or even backups. If our computers running out of space, it's possible that we're trying to store too much data in too little space. Maybe we have too many applications installed, or we're trying to store too many large files in the drive. But it's also possible that programs are misusing the space allotted to them, like by keeping temporary files or caching information that doesn't get cleaned up quickly enough or at all. It's common for the overall performance of the system to decrease as the available disk space gets smaller. Data starts getting fragmented across the desk, and operations become slower. When a hard drive is full, programs may suddenly crash, while trying to write something into disk and finding out that they can't. A full hard drive might even lead to data loss, as some programs might truncate a file before writing an updated version of it, and then fail to write the new content, losing all the data that was stored in it before. Yikes. If it gets to this point, we'll probably see some error, like no space left on device when running our applications or in the logs. So what do you do if a computer runs out of disk space? If it's a user machine, it might be easily fixed by uninstalling applications that aren't used, or cleaning up old data that isn't needed anymore. But if it's a server, you might need to look more closely at what's going on. Is the issue that you need to add an extra drive to the server to have more available space, or is it that some application is misbehaving and filling the disk with useless data? To figure this out, you want to look at how the space is being used and what directories are taking up the most space, then drill down until you find out whether large chunks of space are taken by valid information or by files that should be perched. For example, on a database server, it's expected that the bulk of the disc space is going to be used by the data stored in the database. A mail server, it's going to be the mailboxes of the users of that service. But if you find that most of the data is stored in logs or in temporary files, something has gone wrong. One common pattern of misbehavior is a program that keeps logging error messages to the system log over and over. This can happen for lots of different reasons. For example, the OS might keep trying to start a program that fails because of a configuration problem. This will generate a new log entry with every retry, and can take up a lot of space if there are several retries per second, or it could be that the server has a lot of activity and the logs are real. But there are just too many of them. In that case, you might want to look on the tweaking, the configuration of the tools that rotate the logs more frequently, to make sure that you're keeping only what you need. In other cases, the disk might get full due to a program generating large temporary files, and then failing to clean those up. For example, an application might clean up temporary files when shutting down cleanly, but leave them behind if it crashes. Or it could simply be a programming error of creating temporary files and never cleaning them up. In a case like this, you'll ideally have some housekeeping to fix the program, and delete those files correctly. But if that's not possible, you might need to write your own script that gets rid of them. A situation that might be tricky to debug is when the files taking up the space or deleted files. I'm sure you're wondering, how can deleted files take up space? Great question. Well, if a program opens a file, the OS lets that program read and write in the file regardless of whether the file is marked as deleted or not. So lots of programs delete the temporary files they create right after opening to avoid issues with failing to clean them up later. That way, the process can read from and write to the file while the file is open. Then when the process finishes, the file gets closed and actually deleted. Now, this system is widely used and works fine for most processes. But if for some reason, this temporarily deleted file starts becoming super large, it can end up taking up all the available disk space. If that happens, we'll be left scratching our heads when trying to figure out where most of the data went, since we won't see these deleted files. To check for the specific condition, we need to list the currently opened files, and comb for the ones that we know are deleted. We include pointers to the commands for how that works in the next reading. Of course, there are all kinds of other reasons why the disk may be getting too full. Just remember that whenever this happens, your process will remain the same. You'll need to spend some time looking into what's using the disk. Check to see if it's expected or an anomaly, figure out how to solve it, and most important of all, how to prevent it from happening again? Up next, we'll discuss yet another resource that might cause some trouble. The network.

### Network Saturation

When you work in IT, you interact with services all over the Internet. At one moment, you might connect to a service running on your local network and the next use another service running in a data center located on a different continent. If your network connection is good, you might not be able to tell the difference where the website you're browsing is hosted. But if you're dealing with a network service that isn't exactly up to speed, you might need to get more details about the connection you're using. The two most important factors that determine the time it takes to get the data over the network are the latency and the bandwidth of the connection. The latency is the delay between sending a byte of data from one point and receiving it on the other. This value is directly affected by the physical distance between the two points and how many intermediate devices there are between them. The bandwidth is how much data can be sent or received in a second. This is effectively the data capacity of the connection. Internet connections are usually sold by the amount of bandwidth the customer will see. But it's important to know that the usable bandwidth to transmit data to and from a network service will be determined by the available bandwidth at each endpoint and every hop between them. To understand how latency and bandwidth interact, think about what happens when you try to visit a website over the Internet. If the web server is hosted somewhere across the ocean, the latency might be a 100 milliseconds or so. That's the time it takes for your request to reach the server. The server will then generate a response and send it back to you. The first bytes of the response will again take a 100 milliseconds to zap across the pond to your computer. Once the response is on its way, the time it takes for the rest of the data to arrive is determined by the bandwidth. If the available bandwidth between the two points is 10 megabits per second, you'll be able to receive 1.25 megabytes every second. So for a website of about one megabyte of content, that large initial latency will be noticeable, since it's an extra 20 percent on top of the total time to download it. But if the content is 10 megabytes or more, the initial latency will be less than five percent of the total time to download it. So it matters less. Let's say you're trying to figure out why a network connection isn't going as fast as you want. Remember that if you're transmitting a lot of small pieces of data, you care more about latency than bandwidth. In this case, you want to make sure that the server is as close as possible to the users of the service, aiming for a latency of less than 50 milliseconds if possible, and up to a 100 milliseconds in the worst-case. On the flip side, if you're transmitting large chunks of data, you care more about the bandwidth than the latency. In this case, you want to have as much bandwidth available as possible regardless of where the server is hosted. What do we mean by bandwidth available? Computers can transmit data to and from many different points of the Internet at the same time, but all those separate connections share the same bandwidth. Each connection will get a portion of the bandwidth, but the split isn't necessarily even. If one connection is transmitting a lot of data, there may be no bandwidth left for the other connections. When these traffic jams happen, the latency can increase a lot because packets might get held back until there's enough bandwidth to send them. You've probably experienced this already on your own computer. If you've ever run several applications using the same network at once, the overall connection speed may have seem slower. You can check out which processes are using the network connection by running a program like iftop. This shows how much data each active connection is sending over the network. You might also have noticed that the more users sharing the same network, the slower the data comes in. This is true for home connections and office connections alike. No matter how much bandwidth you have, it's a limited resource. So you'll need to be careful with how you share it among its users. If some applications are using so much bandwidth that others can't transmit anymore data, it's possible to restrict how much each connection takes by using traffic shaping. This is a way of marking the data packets sent over the network with different priorities. To avoid having huge chunks of data, use all the bandwidth. By prioritizing accordingly, processes that send and receive small packets can keep working fine, while processes that need the most bandwidth can use the rest. There's also a limit to how many network connections can be established on a single computer. This isn't usually a problem, but there could be bugs in the software that causes it to open way too many connections, or keep old connections open even if they're no longer in use. If this happens on a server, no new users will be able to connect to it until whatever is keeping those connections open closes them. Up next, we'll try our hand at solving another real-world example. This time, we'll be dealing with a memory leak and adjusting our program to make better use of our resources.

### Dealing with Memory Leaks

There's a ton of reasons why an application may request a lot of memory. Sometimes, it's what we need for the program to complete it's task. Sometimes, it's caused by a part of the software misbehaving. First, let's trigger the misbehavior ourselves to see what this looks like. We'll use a terminal called uxterm for that.
We've configured this terminal to have a really long scroll buffer. The scroll buffer is that nifty feature that lets us scroll up and see the things that we executed and their output. The contents of the buffer are kept in memory. So if we make it really long and we managed to fill it, will cause our computer to run out of memory. With normal use, it might take ages until it happens, but if we run a command that keeps generating a lot of output, we could manage to fill that buffer pretty quickly. Say we run a command like od-cx/dev/urandom. This command will take the random numbers generated by the urandom device and show them as both characters and hexadecimal numbers. Since the urandom device keeps giving more and more random numbers, it will just keep going. Our command is filling up the scroll buffer, making a computer require more and more memory. In a different terminal, let's open top and check out what's going on.
Pressing "Shift M" we tell ton that we want to order the programs by how much memory they are using. We see that the percentage of memory used by uxterm is going up super quickly. Let's stop the process, it's filling up the buffer by pressing "Control C".
With that, we stopped the command that was filling the buffer, but the terminal still has that memory allocated, storing all the lines in the scroll buffer. Let's look at the output of top in a bit more detail. There's a bunch of different columns with data about each process. The column labeled RES is the dynamic memory that's preserved for the specific process. The one labeled SHR is for memory that's shared across processes, and the one labeled VIRT lists all the virtual memory allocated for each process. This includes; process specific memory, shared memory, and other shared resources that are stored on disk but maps into the memory of the process. It's usually fine for a process to have a high value in the VIRT column. The one that usually indicates a problem is the RES column. Let's close the other terminal so that it releases all the memory that it reserved.
In this example, we saw what a program that keeps requesting more and more memory looks like. This was a super extreme example. Most memory leaks don't happen at the speed. It can usually take a long while until we notice that a program is taking more memory than it should, and it might be hard to tell the difference between memory that's actually needed and memory that's being wasted. But looking at the output of top and comparing it to what it used to be a while back is usually how any investigation into a memory leak starts. Let's look at a different example. We have a script that analyzes the frequency of words in web pages. This script works fine when it's just a few web pages, but if we try to give it all the Wikipedia contents, it starts using up all the memory. Let's run it first and see what happens.
This is running and it will take a long while to finish. It's processing a huge amount of articles after all. While this is running, let's look at the output of top in a different terminal and see what we find.
We see that there's a bunch of different content stats processes running. That's because our script is using the multiprocessing techniques that we saw in an earlier video to parallelize the processing of the information and get the results as fast as possible. It seems like these scripts are taking a lot of memory. So let's sort it out to see the details.
We see that the memory used by one of the processes in particular keeps growing and growing. The application is processing a bunch of data and generating a dictionary with it. So it's expected that it will use some memory but not this much. This looks like the program is storing more than it should in memory. This program is pretty complex. So we could use the help of a memory profiler here to figure out what the problem is. Let's stop it now and use a profiler to figure out where our computer's memory is going. To do that, we'll need to use a simplified version of our code as profiling the memory of a multi-process application is extra hard, and instead of processing all the articles, we'll just handle a few so that we can check up the memory consumption quickly. Let's open our simplified script and have a look.
We'll be using a module called memory profiler. This is one of the many different memory profilers available for Python.
We've added this app profile label before the main function definition to tell the profiler that we wanted to analyze the memory consumption of it. This type of label is called a decorator and it's used in Python to add extra behavior to functions without having to modify the code. In this case, the extra behavior is measuring the use of memory. The rest of the code is basically the same as the original one, it just uses a single process and is limited to 50 articles instead of the thousands of articles that the other script was going through.
We're running the script with the memory profiler enabled. This is just reading through 50 articles but it takes a bunch of time because all that memory profiling makes our script slower. Once the program finishes, the memory profiler gives us information about which lines are adding or removing data from the memory used by the program. The first column shows us the amount of memory required when each line gets executed. The second one shows the increase in memory for each specific line. We see here that after going through 50 articles, the program already took 130 megabytes, no wonder we ran out of memory when we were trying to process all the articles. We can see that the variables that require the most memory are article and text, with about four and of three megabytes respectively. Those are the articles we're processing, and it's fine for them to take space while we're counting the words in the article. But once were done processing one article, we shouldn't keep that memory around. Can you spot the problem?
Right at the end, the code is storing the article to keep a reference to it, but it's storing the whole article. If we want to keep a reference to all the articles that include a word, we could store the titles or the index entries, definitely not the whole contents. There's a ton more to say about memory management and memory profiling that we don't have time to cover here. In the next reading, we've gathered a bunch of interesting links to information about managing scarce resources. After that, there's another practice quiz for you.

## Managing Our Time

### Getting to the Important Tasks

In earlier videos, we discussed how to make better use of the resources available on our computers and systems, like the CPU, the memory, the disk, the network, and so on. But, there's another resource that's even more valuable in our day to day, our time. As humans, we want to make sure that we spend our time doing meaningful activities, like work that we enjoy, and earning the satisfaction of a job well done. When working, we need to optimize the time we spend to bring the most value to the company. Finding the right balance is hard, but that's what we're here for. From updated calendars, to social media detoxes, there's lots of different ways to optimize our time. One that's super effective when working in IT is the Eisenhower Decision Matrix. When using this method, we split tasks into two different categories: urgent and important. There are tasks that are important and urgent. Draw alarm bells around them if you'd like because these need to be done right away. For example, if the company's Internet connection is down, it's both urgent and important to get it back up as soon as possible. Some tasks are important, but not urgent, so they need to get done at some point even if it takes a while to complete them. For example, as a follow-up to the network being down, it would be important to make sure that there's a backup network connection so that if the existing one is ever down again, the company can stay connected using the backup. Other tasks might seem urgent, but aren't really important. A lot of the interruptions that we need to deal with are in this category. Answering email, phone calls, texts, or instant messages feel like something that we need to do right away. But most of the time are not really the best use of our time. Finally, there's a whole category of tasks that are neither important nor urgent. These are distractions and time wasters, they shouldn't be done at all. These include: meetings where nothing useful is being discussed, email threads that lead to nowhere, office gossip, no thanks, and any other tasks that eat up our time without giving anything valuable in return. In general, to make the most of our time, we need to make sure that we're spending the majority of it on tasks that are important. Of course we'll want to get to the urgent tasks as soon as possible, but we need to block some time for long-term planning and execution. Spending time on long-term tasks might not bear fruit right away, but it can be critical when dealing with a large incident. For example, setting up your infrastructure so that you can easily roll back changes or deploy new servers when needed takes a large chunk of time. But investing in the future can save you even more time and user frustration when responding to a problem. Researching new technologies is another task in this category. IT is always evolving and it's important to have time set aside to stay up to date. Figure out if it's time to migrate the web server to different software, update the mail server to a new OS version, or deploy voice-over IP throughout your company. Another important task that might not necessarily be urgent is solving technical debt. When you work in IT, you waste time a lot. What does it mean? Technical debt is the pending work that accumulates when we choose a quick-and-easy solution instead of applying a sustainable long-term one. We call that a few times already though in solving the problem we might apply a short-term remediation to fix it right away, and then plan for a long-term solution to prevent it from happening in the future. Until we have fixed the sticks, the workaround we created is technical debt because we need to spend time keeping it in place even if it's not the best solution. Whenever we go for short-term solution and leave the long-term solution for later, we're creating technical debt. This might be the right decision in the moment to get us out of a crisis and let our users get back to work, but we need to unscheduled time to apply the long-term solution that will make our future lives easier. Technical debt can also be generated by external parties. For example, when a new version of the software we're using is released, will need to schedule time to upgrade it. Until we do, that pending upgrade is technical debt. So we've made it clear that we need to focus our work on tasks that are important, but what can we do about interruptions which are urgent but not important? If you work in IT support, you have to be interrupted, it's part of the role. So you'll need to plan to deal with those interruptions effectively. If you work on a team, you can rotate the person dealing with those interruptions. Maybe someone takes care of them in the morning and a different person in the afternoon, or you take turns each day. If you work independently, you can try to establish a set of ours when users can expect to reach you for a normal requests, and the rest of the time only be available for emergencies. The key here is to have a window of time reserved when you're not going to be interrupted. That's the time when you can get the most important tasks done when you can fully concentrate on dealing with complex issues and finding solutions for tricky problems. Depending on your role and how the company works, you might need to get this work done in a different location to avoid people walking up to your desk, or actively silencing any of your notifications to avoid getting interrupted and distracted by unimportant conversations. So assuming that you've managed to set some time aside to work on these important but not urgent tasks, how do you make sure that you work on the right things with the right priorities? That's coming up in our next video.

### Prioritizing Tasks

In our last video, we talked about how we need to make sure that we have the time available to work on tasks that are important, but not necessarily urgent. But sometimes it feels like everything is important, and everything is urgent. Say you need to deploy a new computer for the person that's starting tomorrow. Upgrade the VPN service to the latest version because the old one has a security vulnerability. Fix a permissions problem that's preventing a group of users from accessing the inventory data. Check out a problem with the mail system that's causing some emails to get randomly rejected. And so many other things that by now you've lost track of them. What can you do to figure out how to spend the limited time that you have? There's a lot to say about this, and everyone works a little differently. So you'll need to find the system that works best for you. But let's cover the basic structure that can help us get organized and prioritize our tasks. The first step is to make a list of all of the tasks that need to get done.
You can make this list on a piece of paper, a text file in your computer, a bug tracking system, or a ticket management system. Whatever works for you. The point is to have all the tasks listed in one place to avoid depending on your not always perfect memory later. Once you have the list, you can check the real urgency of the tasks. Ask yourself, if any items don't get done today will something bad happen? If yes, then those should be worked on first. Once you're done with the most critically urgent tasks, you can look at the rest of the list and assess the importance of each issue.
Even when it looks like everything is important, you should be able to tell that some things are more important than others. For example, a task that will benefit more people is more important than a task that will benefit less people. If there are a bunch of different tasks that depend on you completing one, that roadblock is more important to clear than the rest. If it still seems like everything is on fire, you can try dividing the tasks into groups of most important, important, and not so important. And then sort the tasks inside each group, but don't spend too much time doing this sorting. In the end, the exact order isn't what matters. What matters is that you spend most of your time working on the most important tasks. And if you work with a team of people, it's a good idea to share both the list of tasks and the standard of prioritization among team members. This helps you avoid having to do the work multiple times and coming out with different priorities. Once you have a list of the most important tasks to work on, you'll want to have a rough idea of how much effort they'll take.
We'll talk more about estimating times in the next video. This isn't about exact timing, it's about assigning rough sizes. One common technique is to use small, medium, and large. And when the range of sizes is big enough, include extra small or extra large if needed. Once you identify the most important tasks and how big they are, you can start working on them. If possible, try to start with the larger, most important tasks to get those out of the way first. But as we called out, when our work involves IT support, we know that we'll have to deal with interruptions. And working on complex tasks while getting interrupted can be very frustrating. I hear that. One strategy that can help us with that is saving the most complex tasks for the moments when we're less likely to get interrupted. If you know that you get busiest in the morning, and you tend to have more quiet time during the afternoon, it makes sense to work on easy and quick tasks early in the day. Save the most complex tasks for later, when you'll have more time to concentrate on them. But when your focused time starts, you should make sure that you work on those large complex tasks and not on the easy ones. Otherwise, the complex tasks will never get done. The key here is to always work on important tasks. If a task is not important, it shouldn't be done at all. Really, we live by this rule here at Google.
Then select which task you're going to deal with depending on urgency and how much time you can devote to it, starting with the biggest tasks that you can fit in the time you have available. But keep in mind, this shouldn't stop you from taking a break or working on experimental projects. Taking breaks is important because it allows our creative minds to stay fresh, and working on a fun side project can help us research emerging technologies and come up with new ideas. Did you know that this very certificate program got its start as a side project at Google? Okay, but what if the unthinkable happens? What can we do if after all of this prioritizing, sizing, and ordering there's just too much work to be done and too few hours in the day? The first thing to know is this is normal, most people working in IT have too much to do and can't get all the things they want done. Unfortunately, us humans can't multiply ourselves on command yet and working extra hours is not sustainable long-term. Which means there are basically two options, either you get extra help from other team members or you decide that some tasks weren't really that important, and they won't get done. For both of these options, you'll need to involve other people, like your manager, and make sure that expectations get clearly communicated.
Some tasks, like fixing the permissions in a directory, changing a faulty keyboard, or installing a new application on a single computer, can be self-contained and completed in a small amount of time. Other tasks, like upgrading the database software to a new version, automating the creation of user accounts, or writing a wrapper to adapt to incompatible programs, are larger projects that can take several days or maybe even weeks to complete. When that's the case, it's important to have a rough estimate of how long the tasks will take to be completed and to clearly communicate expectations to those affected. We'll cover these two aspects in the next couple of videos.

### Estimating the Time Tasks Will Take

As we've called that before, when deciding whether a manual task needs to be automated, we should consider two things; how many times we'll do the task over a period of time and how long it takes to do it manually. From there, we can figure out if that number is larger than the time it will take us to write the automation. This sounds great in theory, but the problem is that we don't know how long it'll take us to write the automation until we've actually written it. All we can do is estimate it, and most of us are really bad at estimating how long tasks will take. We tend to be too optimistic about the amount of time that a certain piece of code will take us to write or a certain infrastructure will take us to set up. Usually, our first instinct is to consider how much we can get done with an ideal amount of focus on the work and a full grasp of the problem we're trying to solve. We forget to take into account the many obstacles that we might face like finding a bug that we don't know how to fix, being interrupted by a problem that needs more urgent attention, or discovering that a new tool doesn't work well with the rest of the tools we have in place. So if you're trying to estimate how long it will take you to complete a project, big or small, you need to be realistic. Avoid being overly optimistic with your time estimates. The best way to do this is to compare the task that you're trying to do with similar tasks that you've done before. This way, you're not estimating based on how long you would like the project to take but on how long other similar projects actually took in the past. If the task at hand is large, it might be hard to find something similar enough to use for comparison. So to make a better estimate of a bigger than average project, you'll want to chop it up. Split the task into smaller steps. Compare each step to a similar task that you've done in the past and assign an estimated amount of time to each step based on that. If one smaller step is still too large, then split it into even smaller pieces until you can compare each piece of the puzzle was something that you've done before. Once you've got all those estimated times, just add them up and you'll have a rough estimate of how long the whole task will take. But even that's going to be optimistic since putting all the pieces together will take additional time. So once you have a rough estimate of the total time of all the steps, you want to factor in some extra time for integration. This should also come from prior experience. Think about how long it took you to integrate the pieces of a project before, and you'll have a rough idea of how much to add to the previous value. Time really flies huh? Knowing how optimistic we humans are, even after basing those estimations on previous experience, the number you come up with is going to be very close to the best possible scenario. Even if you're prepared for something to go wrong, it's impossible to anticipate new unknown bumps in the road, so take this estimation and multiply it by a factor. Once again, this factor works best when it's based on previous experience. So if the last time you did this exercise, it took you three times longer to complete the task than you'd planned, go ahead and multiply your estimation by three. This might seem like we're inflating the numbers, but remember, you want to have a grounded estimate of how long it will take you to complete the task. That means taking into account the obstacles that you'll certainly run into but haven't come across yet. No matter how detailed we are, the final estimation won't ever exactly match the time it takes, but it will give us a rough idea of whether we can complete the task in a few hours, days, weeks, or months. Once you've made your estimation, you want to note it down somewhere so that you can check later to see how close you were to the original number. You can adjust future estimations based on that. You will also want to communicate with those affected and let them know when they can expect the task to be done. We'll talk more about that in our next video.

### Communicating Expectations

When you're dealing with an issue that's affecting one or more users, you might feel rushed to meet expectations, SAP or the people you're helping. Everyone's got their own ideas of how long it will take you to solve the problem and when they can expect a solution. They might be wondering, what's the holdup? If the issue is that the users spilled coffee on their keyboard and needs a new one, the expectation is that replacing the keyboard will be a very small task that will take almost no time. If the issue is that there's a new employee starting soon and they need a new computer setup for them, the expectation is that it will take much longer than replacing a keyboard. Even if we have an automated process for setting up new computers, which means there's very little manual work, to have successful interactions with our users, it's important to understand these implicit expectations and let users know if fixing the problem will take longer than they expect. Users will be happy if the issue is resolved within their expectations, but will become frustrated if it takes much longer than they thought. But as long as we communicate with them early about the circumstances, they will be able to understand this and manage their time accordingly. Say you have to replace a keyboard but you have no spares available. This means, you'll need to buy a new one or maybe even a whole batch to have a spare available next time. It's important to communicate upfront to the user that in this case, the replacements will take more time and then figure out how critical getting the replacement is. If the user is an accountant, working on the salary deposit order, which needs to be sent to the bank in one hour or nobody gets their payment on time, you might opt for giving them your keyboard while you go and buy another one at the closest hardware store. On the flip side, if the user can work on their laptop until the next day when a new batch of keyboards is scheduled to arrive, you don't need to go out of your way to get early replacement. It's also important to let users know if there are any conflicting priorities that might delay the response to whatever they need. Say a user calls you to request access to a shared resource, but you're in the middle of dealing with an issue that's causing the company's database to be offline. Even if the user request is quick and easy to solve, fixing the database is critical and affects the whole company, so it should take priority. In this case, make sure you tell the user that you're dealing with a crisis and that you'll help with their request once the crisis is resolved, give them an idea of when they can expect their issue to be fixed so they can plan what to do next. So as a general rule, communication is key. Try to be clear and upfront about when you expect the issue will be resolved, and if for any reason the issue isn't solved by then, explain why and what the new expectation should be. Unfortunately, when the issue you're trying to solve involves troubleshooting and debugging, it's usually very hard to give an accurate estimate of how long it will take you to fix the problem. Notice a theme, estimating the time it takes to perform more complicated work is tough. A lot of your time will be spent investigating looking into what's going on and figuring out what should be happening. In that case, make sure to let users know when they can expect an update on their issue and give them timely updates, if possible it's a really good idea to have users filed the requests through a ticket tracking system. Using a system like this has a ton of advantages. Having all the work you need to do in one place lets you organize your tasks by priority as we discussed before. Receiving reports of issues through a system instead of a phone or chat, lets you make better use of your time. You can now decide when you'll look at the list of issues instead of getting interrupted in the middle of a task, and when you have an update for an issue that you've been working on, you can easily update the ticket with news without having to track down users to let them know what's up with their request. Finally, try out some practical shortcuts when dealing with users. It makes sense to take some time to think about the work you do and figure out ways to avoid interruptions and save time. For example, if a user tells you that their mouse doesn't work, your first instinct might be to go check it yourself and then bring a new one if necessary, but that's a lot of back and forth, instead you could ask the user to bring the faulty mouse to you so that you can test it at your computer and if it's broken change it with a new one or even better, if you trust your users, you might even leave a set of mice, keyboards, and other accessories available for users to take when the one they're using breaks down. That's what we do here at Google and it saves us a ton of time and frustration. Along the same lines, if your company's budget allows, you could have a couple of spare computers ready to be used. That way, when a computer breaks down, you can get the user back to work as quickly as possible, then you can debug the faulty computer at your own pace. But not every issue can be solved by having spare devices. Sometimes spending time on improving your infrastructure can help you get more done in less time. Automating processes like installing new computers, setting up new user accounts, deploying virtual machines, or rolling back changes to previous versions can help save you a lot of time when you're responding to an incident. Up next is a reading, including links with more information on how to make the best use of your time, followed by a practice quiz to check that all of this made sense. Should be an easy one, considering how fast you're chugging through this module.

## Making Our Future Lives Easier

### Dealing with Hard Problems

You might be wondering, why is debugging so hard that we need an entire course on it? Brian Kernighan, one of the first contributors to the Unix operating system and co-author of the famous C programming language book, among many other things, once said, everyone knows that debugging is twice as hard as writing a program in the first place. So if you're as clever as you can be when you write it, how will you ever debug it? This is a warning against writing complicated programs. If the code is clear and simple, it will be much easier to debug than if it's clever but obscure. The same applies to IT systems. If the system is engineered very cleverly, it will be extremely hard to understand what's going on with it when something fails. It's important to focus on building systems and applications that are simple and easy to understand. So that when something goes wrong, we can figure out how to fix them quickly. So how do we do this? One piece of advice I found really valuable is to develop code in small, digestible chunks. Every so often, I stop and test what I've written. The hardest thing to do is to try to debug something if I'm running it for the first time only after I've completed it. There are so many places things could have gone wrong. Another lesson that's super useful is to keep your goal clear. If you're writing code, try writing the tests for the program before the actual code to help you keep focus on your goal. If you're building a system or deploying an application, having documentation that states what the end goal should be, and the steps you took to get there can be really helpful. To both keep you on track, and figure out any problems that might turn up along the way. We called out at the beginning of this course that solving technical problems is a bit of an art, and that it can be fun when things finally click together. On the flip side, the worst part of troubleshooting and debugging is when we get stuck. When we can't think of any other reasons why the program is failing, or we can't figure out what else we can do to fix it. In this course, we've given you a bunch of tools and processes to follow that can hopefully help you avoid getting stuck on a lot of these situations, but we can't cover absolutely everything. You might still find yourself facing an issue that you have no idea what to do about, and that's okay. If you're in a sticky situation, the main thing to do is to remain calm. We need our creative skills to solve problems, and the worst enemy of creativity is anxiety. So if you feel that you're out of ideas, it's better to take your mind off the problem for a while. Maybe grab a cup of coffee, or take a walk outside. Sometimes a change of scenery is all we need for a new idea to pop up and help us figure out what we're missing, true in coding and in life. If the problem you're trying to solve is complex and affects a lot of people, it can get really stressful to try to fully debug it with everyone waiting on you. That's why it's better to focus first on the short-term solution, and then look for the long-term remediation once those affected are able to get back to work. And don't be afraid to ask for help. Sometimes just the act of explaining the problem to someone else can help us realize what we're missing. There's a technique called rubber duck debugging, which is simply explaining the problem to a rubber duck. It sounds whimsical, and you may look like a quack, but it can really work. Because when we force ourselves to explain a problem, we already start thinking about the issue differently. And remember that no one knows absolutely everything. Sometimes the best way to learn new skills and techniques is to ask others for help. We're all in this thing together. There are times when I know that if I spend enough hours on a problem, I'll probably figure out a solution, but is that the best use of my time? Usually, the better answer is to ask someone who has done it before, to save time and frustration. And then use the problem at hand as an opportunity to keep learning, so that the next time, I can do it on my own. When you ask a colleague for their help with debugging a problem, be careful not to tell them what you think the root cause of the issue might be. Instead, tell them about the symptoms, and see what questions they ask and what possibilities they probe. They might come up with completely different paths to explore. Of course, our lives as IT specialists would be much easier if we could avoid problems altogether. Up next, we'll look into some proactive approaches to catching issues before they affect any users.

### Proactive Practices

Something that IT specialists and exterminators have in common is dealing with bugs. I just love a good coding joke. Anyhow, moving on, it can be bugs in our software or someone else's software. But we'll come across lots of bugs that trigger lots of different failures in our programs. There's a bunch of strategies we can adopt to make our lives easier, by catching issues before they affect our users or making troubleshooting simpler by having better information. We've touched upon some of them here and there but now, it's time to deep dive. To avoid having to scramble to fix things when there's an outage, it's really helpful to have infrastructure that lets us test changes in advance so that we can check that things are working as expected before they reach our users. If we're the ones writing the code, one thing we can do is to make sure that our code has good unit tests and integration tests. If our tests have good coverage of the code, we can rely on them to catch a wide array of bugs whenever there's a change that may break things. For these tests to be really meaningful, we need to run them often, and make sure we know as soon as they fail. Setting up continuous integration can help with that. Another step in this direction is to have a test environment, where we can deploy new code before shipping it to the rest of our users. This serves two purposes. First, we can do a thorough check of the software as it will be seen by the users. Depending on the software and how often we update it, we can do both automated and manual tests in this environment. Second, we can use this test environment to troubleshoot problems whenever they happen. We can try possible solutions and new features without affecting the production environment. Taking this even further, another recommended practice when managing a fleet of computers is to deploy software in phases or canaries. What this means is that instead of upgrading all computers at the same time and possibly breaking all of them at the same time, you upgrade some computers first and check how they behave. If everything goes fine, you can upgrade a few more, and so on until you're confident enough to upgrade the remaining part of the fleet. As the saying goes, like a canary in a coal mine. To make the best use of this practice, we'll need to be able to easily roll back to the previous version. Depending on the software, this might require more or less infrastructure. But trust me, it's worth spending the time setting up that additional infrastructure. If you deploy to software version that was broken and suddenly a bunch of your computers aren't working correctly, you'll want to roll them back to a previous state as fast as possible. Now, even with all these preventative measures, bugs will still filter through and problems will occur. We can make our troubleshooting easier by including good debug logging in the code. That way, whenever we have to figure out an issue, we can look at the logs and get a pretty good idea of what's going on. Another method that can help us is having centralized logs collection. This means there's a special server that gathers all the logs from all the servers or even all the computers in the network. That way, when we have to look at those logs, we don't need to connect to each machine individually, we can comb through all the logs together in a centralized server. Similarly, having a good monitoring system can be super helpful. We can use it to catch issues early before they affect too many users. During a debugging session, we can look at the collected data to try to determine if there's anything out of the ordinary going on. We called out ticketing systems a few times already, because we can't stress their importance enough. Making good use of them can help us save a lot of time when trying to get to the bottom of a problem. If we ask users to provide the needed information up front, we don't have to waste time and go back and forth. Even here, we can look at opportunities for automation. Say you almost always want some specific info from the users computers, you can automate getting it by creating a script that gathers all the data you want and have the users attach it to the ticket. Finally, remember to spend time writing documentation. Just as importantly, store the documentation in a well-known location. Even if writing documentation isn't especially fun, having good instructions on how to solve a specific problem, knowing how to diagnose what's going on with the server, or tracking the known issues in a system can be real time savers. At Google, we have a bunch of docs called Playbooks where we detail what a person who's on call can do to diagnose and mitigate a ton of different problems. By keeping this information updated, we make sure that no matter who the person on call is, everybody has access to the knowledge base accumulated by the whole team. It doesn't stop there. If we're dealing with systems that change and grow, we can proactively plan for the additional capacity that we'll need in the future. Speaking of planning ahead, you can plan to hear more about this in our next video.

### Planning Future Resource Usage

We discussed in earlier videos what we can do when our programs are misusing resources like memory, disk, network, or CPU. But sometimes, it's not a question of misusing resources, but rather missing resources. A database server is expected to use more disk storage as more data gets stored. Or a web server is expected to use more network bandwidth as the service grows in popularity. If you're dealing with a service that's expected to grow and will acquire more resources in the future, it makes sense to spend some time thinking about what that might look like. Planning ahead will prepare you for when you need additional resources, instead of having to scramble for them at the last minute. Lets say the database growth is expected to be one megabyte per day, and you have 500 megabytes of free-space. You can use that storage for almost two years. But if the growth is expected to be 10 megabytes per day and you only have those 500 megabytes available, then you need to start figuring out a plan that will allow your database to keep growing at that pace. Otherwise, you run out of space in a couple of months. Once you've figured out the current usage and the expected growth, don't forget to write this down so you can refer to it in the future and check if anything has changed. If you find that you'll soon be running out of space, what you'll do next will depend on what the system does, and the importance of the data. You might decide that you don't really want to store all that data, and instead clean up anything that's not really necessary, or you might decide that you really need to have a lot more storage available. In that case, you might opt for buying a network attached storage or NAS that can be attached to your server for additional disk space. Migrating to a different type of storage takes time, and can be tricky to do right under pressure. So it's important to do this kind of planning in advance and not wait until the disk is completely full. This means monitoring the usage growth of the computer to see if there are any trends that need attention. If the service using the database suddenly becomes very popular, the daily growth can increase so much that we'll need to find a better solution sooner than we thought. Our monitoring system should trigger an automatic alert when that's the case. An interesting strategy for making the best possible use of resources, is to mix and match the processes that run on the computers, so they make use of all the available resources. If you have a process that's CPU intensive and takes almost all the available CPU on a computer, you can still run processes that are IO intensive, reading and writing a lot of data to the hard drive. Or if you have a service that requires a lot of RAM, you can pair it with another one that uses very little memory, and mostly sends and receives data over the network. An alternative for having to deal with all these resources like figuring out when to buy more and how to distribute them, is to migrate those systems to the Cloud. Setting up your service to run on the cloud will require some initial setup time, as well as an ongoing cost for the Cloud resources you're using. But while this is more expensive than what you'd pay when running the service on premise, you're basically delegating all your capacity planning needs to your Cloud provider. That way, if the initial setup doesn't have enough space, you can simply attach a bigger hard drive. Or if the program needs more RAM, you can just deploy the service in a virtual machine with more memory assigned. If you decide that moving to the Cloud is a good way to go for your company, remember that you'll also need to plan for that. Migrating your services to run fully or even partially in the Cloud, requires work on your side. So you'll need to decide if and when to make the leap, to avoid your service having an outage because it ran out of resources. Still with us, you're doing great. We're coming towards the end of the module, and I hope you are as proud as we are of the progress you've made. Your thinking ahead and learning some seriously important skills that will serve you well up there in the word, which brings us to our last topic; making sure that problems are properly addressed in a long-term.

### Preventing Future Problems

Throughout our course, we've called out several times that, whenever we're faced with an issue, it's usually best to find a quick workaround. So that those affected can get back to work as soon as possible. Say your database server crashed because it ran out of space. You can solve it quickly by adding an extra hard drive and starting the service back up. But remember, our work doesn't finish there. Once the affected users are happily doing their job, we need to look for a long-term solution that will prevent the problem from happening again in the future. In the database server scenario, that would be detecting that the disk is running out of space before it happens. So how do we do that without a crystal ball? One key strategy is to make good use of monitoring. There's a lot to say about monitoring, so much that we could have a whole course on this subject. The short version of it is that you want the computers you care about to send their data to a centralized location that aggregates all this information. And then you want to be able to look at both the information yourself, and trigger alerts when the values are not within acceptable range. When you first set up a monitoring system, you might not be sure what information to prioritize, so start with the basics, CPU, disk, memory, and network usage. As time passes and you have to deal with more incidents, you'll probably discover other metrics that you'd like to include in your monitoring system. For example, if you have to debug a problem related to a computer overheating, you'll want to include the temperature sensor's data in your monitoring system. You'll also want to include information related to the specific service running on the computer. If it's a web server, you'll want to know the ratio between successful web responses and errors. If it's a database server, you'll want to know how many queries that are being served over time. And whenever you have to deal with an incident that wasn't caught by the monitoring system, remember to set up new monitoring and alerting rules that will notify you about the problem if it ever happens again. An important capability of monitoring is to include the measurements taken along a period of time. That way, we can keep track of how we're using our resources, and catch changes in tendencies early on to help us with planning. Having good monitoring will let us know early on if things are broken. But how do we make sure that the things we fix stay fixed? We've mentioned this already, but it's worth repeating. If you have to work around an issue in an application developed by someone else, it's important that you report a bug to the relevant developers. That way, those in charge of the code can take your case into account and make it work correctly in the future. If you don't do this, it's possible that the workaround you figured out for the current version is not sufficient for the next version, and you'll have to figure out a whole new workaround. When reporting a bug to someone else, remember all the best practices that we talked about earlier. Let them know what you were trying to achieve, what you did, what the expected result was, and what the actual result was. Include your reproduction case and workarounds for the issue. If you have access to the source code of the project, providing a patch that fixes the issue increases the chance of that code getting fixed. On the flip side, if you have to work around an issue in the software that you own, make sure that you write a test that catches the problem.
That way, you can be sure that you won't ever make a change to the code that will trigger that same issue again. And even if you're not in charge of the development of the software, you can still run automatic tests whenever there's a new version, just to check if it still works as expected. So make sure you perform these tests whenever a new version of the application comes around. Finally, regardless of whether the bug came from software that you wrote or someone else wrote, make sure that you document the key pieces of what you did, how you diagnosed the issue, and how you squashed it. That way, if the issue happens again, you or whoever else needs to deal with it will be able to quickly apply the solution, instead of spending valuable time investigating. Coming up, a quick quiz to make sure that all these concepts have made sense.

### More About Preventing Future Breakage

Preventing future breakage is a bit of a dynamic subject. Probably the most useful techniques here are identifying, isolating, and managing problem domains and failure domains. 

Problem Domains just describe the complexity of a given problem that one is trying to solve. Let’s look at an example below:

For example: counting the number of occurrences of a specific word in one of Shakespeare’s plays, like Hamlet. This is an indexing problem. And its problem domain is fairly limited in scope. It’s a single word, and a single play. A bit of BASH could easily solve this problem. So the problem domain is small, and the technical solution is fairly simple.

However, if the scope is widened slightly to include all of Shakespeare’s plays, the problem domain becomes larger. Any software solution used to try and solve this indexing problem has to now handle various logic that it did not have to handle before, like consolidating word occurrences in various plays. I.e. the word ‘Brevity’ may occur at least once in Hamlet, and N number of times in various other plays. Managing N occurrences of ‘Brevity’ over M works of Shakespeare is an order of magnitude more complex in terms of describing the problem domain. A bit of BASH could solve this problem, but it might be difficult.

If the problem becomes slightly more complex, such as finding the occurrences of various synonyms to a given word, then the problem domain becomes equally large. Managing original words, their synonyms, and their hit-count across multiple works of Shakespeare is even MORE complex.

So why is any of this useful? Well, if one can easily describe and reason about a problem in a lot of detail, they understand the Problem Domain fairly well. Producing a software solution for a given problem becomes easier when the Software Engineer understands the problem domain fairly well. Of course, building a good understanding of the Problem Domain often requires a lot of experimentation, and iteration. This is why it’s good to make a few initial attempts at testing a design before building an entire Production system to solve a problem like indexing Shakespeare.

Failure Domains
Like problem domains, failure domains just describe the complexity of a system. Except, instead of describing the various problems a system tries to solve, failure domains describe various sub-systems which may fail. Using the Shakespeare example again, if one of your systems is responsible for managing the full text of the works of Shakespeare (a content server), that might be a single failure domain. If another system is responsible for actually searching that content and counting the words (an indexer), that is a separate failure domain. Some failure domains can be within other failure domains. For example, if an indexer fails, the content server may not fail. But if a content server fails, the indexer will probably also fail.

So why do we care about any of this? Well, Problem Domains drive system complexity. Complex systems often have many failure domains. The key to preventing future breakage is to identify, and manage the scope and severity of a failure domain. This may mean redesigning the system in a way that has many smaller failure domains, instead of few large ones. 

As another example It’s better to have a video streaming service slow down instead of failing entirely. This kind of graceful degradation is can be attributed to isolated failure domains.

This topic can be a bit complex, but there are several community articles on the idea of identifying and managing failure domains. Consolidating and completely eliminating possible failure domains is the key to preventing future breakage. If anything, managing failure domains should keep the scope of a break as small as possible.

Check out some more info here:

https://simpleprogrammer.com/understanding-the-problem-domain-is-the-hardest-part-of-programming/
https://blog.turbonomic.com/blog/on-technology/thinking-like-an-architect-understanding-failure-domains
https://landing.google.com/sre/sre-book/chapters/effective-troubleshooting/

## Module Review

Wow, look at all we've covered. In the past videos, we discussed a lot of different topics that are relevant for those of us dealing with problems in IT. We spoke in depth about what limits the resources available to us, including memory, disk space, and network. We've looked into how we can make better use of those resources, both in terms of hardware and from the human point of view. We discussed how we can make the best use of our time by prioritizing tasks using the Eisenhower Decision Matrix. We covered how we can work proactively to anticipate and prevent issues from happening. We also talked about the best approaches to estimate time spent and how to communicate expectations to users. We discussed tactics for dealing with hard problems, like establishing test environments, monitoring, canaries, and rollbacks. That was a lot of interesting stuff in a short amount of time, don't you think? Throughout this course, you've learned a lot about the different approaches you can take to understand and fix tons of different IT related problems. Now, once again, it's time to put this into practice. Up next, the last graded assessment of the course. In this assessment, you have to put into practice all the knowledge that you've acquired this far. You'll need to figure out what's going on with a system that's not behaving as expected, and find a way to fix it. You've got this.

## Course Wrap Up

Congrats on solving that tricky lab, it definitely wasn't easy. And congrats on completing the whole course. We've learned a ton of stuff in our time together, and I'm really proud of you for making it all the way here. With the knowledge that you've learned through this course you're now much better equipped to deal with any kind of problem that you might face in your IT job. You've learned how to deal with issues in your computer, in your code, and in your systems. We've looked into a bunch of different ways in which software can fail, and we figured out how to tackle a lot of them. In our journey together we checked out a ton of examples based on real-world situations that people like you or me come across in our IT jobs regularly. We've given you an open playbook of the tips and tricks used by those of us at Google to solve the same problems every day. And all along you've been applying what you've learned to solve real-world problems yourself through our quick labs. Practice like that builds some serious problem-solving experience helping you grow in your it role. To me knowing how to identify, solve, and prevent those types of problems is one of the most important parts of working in IT. And building the healthy habits needed to prioritize my time when working with those problems is just as critical. I'm super glad to have shared this journey with you and I wish you the best in your next adventures, good luck.